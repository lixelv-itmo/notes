## Определение
**Задача о рюкзаке** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Knapsack Problem) - классическая задача комбинаторной оптимизации. Дано:
- $n$ предметов, каждый с весом $w_i$ и ценностью $v_i$
- Рюкзак с максимальной вместимостью $W$

**Цель:** выбрать набор предметов с максимальной суммарной ценностью, не превышая вместимость рюкзака.
Формально: максимизировать $\sum_{i=1}^{n} v_i \cdot x_i$ при ограничении $\sum_{i=1}^{n} w_i \cdot x_i \le W$, где $x_i \in \{0, 1\}$.

---
## Сложность
--- start-multi-column: ExampleRegion1  
```column-settings  
number of columns: 2  
Border: false
Shadow: false
```

**0/1 рюкзак (ДП):**
- **Время:** $O(N \cdot W)$
- **Память:** $O(N \cdot W)$ или $O(W)$

**Дробный рюкзак:**
- **Время:** $O(n \log n)$
- **Память:** $O(1)$

--- end-column ---

![](backpack.png)

--- end-multi-column

---
## Варианты задачи о рюкзаке

### 0/1 Рюкзак (0/1 Knapsack)
- Каждый предмет можно взять **только один раз** ($x_i \in \{0, 1\}$).
- Решается методом **[динамического программирования](Динамическое%20программирование.md)**.
- NP-полная задача в общем случае.
- Псевдополиномиальная сложность $O(n \cdot W)$.

### Неограниченный рюкзак (Unbounded Knapsack)
- Каждый предмет можно брать **неограниченное количество раз** ($x_i \in \mathbb{N}_0$).
- Также решается динамическим программированием.
- Сложность $O(n \cdot W)$.

### Дробный рюкзак (Fractional Knapsack)
- Можно брать **части предметов** ($x_i \in [0, 1]$).
- Решается **жадным алгоритмом**: сортировка по убыванию $\frac{v_i}{w_i}$.
- Сложность $O(n \log n)$ (время сортировки).

---
## Реализация на C

```c
int max(int a, int b) {
	return (a > b) ? a : b;
}

int knapsack_01(int W, int weights[], int values[], int n) {
	int dp[n + 1][W + 1];
	
	// Инициализация базовых случаев
	for (int i = 0; i <= n; i++) {
		for (int w = 0; w <= W; w++) {
			if (i == 0 || w == 0)
				dp[i][w] = 0;
			else if (weights[i - 1] <= w)
				dp[i][w] = max(
					values[i - 1] + dp[i - 1][w - weights[i - 1]],
					dp[i - 1][w]
				);
			else
				dp[i][w] = dp[i - 1][w];
		}
	}
	
	return dp[n][W];
}
```
---
## [Wiki](https://ru.wikipedia.org/wiki/Задача_о_рюкзаке) [DSA](https://www.w3schools.com/dsa/dsa_ref_knapsack.php)