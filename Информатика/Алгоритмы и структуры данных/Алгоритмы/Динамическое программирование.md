## Определение
**Динамическое программирование** (ДП, англ. Dynamic Programming, DP) — это метод решения сложных задач путём разбиения их на более простые подзадачи, решения каждой из этих подзадач только один раз и хранения их решений. Когда та же самая подзадача встречается снова, вместо повторного вычисления используется уже сохранённый результат. Этот подход особенно эффективен для задач, обладающих свойствами **оптимальной подструктуры** и **перекрывающихся подзадач**.

*   **Оптимальная подструктура**: Оптимальное решение исходной задачи может быть построено из оптимальных решений её подзадач.
*   **Перекрывающиеся подзадачи**: Одна и та же подзадача встречается несколько раз в процессе решения более крупной задачи.

В отличие от [алгоритмов](Информатика/Алгоритмы%20и%20структуры%20данных/Алгоритм.md) "разделяй и властвуй", которые также делят задачу на подзадачи, ДП повторно использует решения перекрывающихся подзадач, часто улучшая временную [асимптотику](Асимптотика%20алгоритмов.md) со сложностью $O(2^n)$ до $O(n^2)$ или $O(n \log n)$.

---
## Подходы к реализации

Существует два основных подхода к реализации динамического программирования:

### 1. Мемоизация (Top-Down)
Рекурсивный подход, при котором функция вызывается для решения задачи, и если результат для данной подзадачи уже был вычислен и сохранён, он возвращается. В противном случае, подзадача решается, и её результат сохраняется перед возвратом.

*   **Идея**: Сверху вниз. Мы начинаем с исходной задачи и рекурсивно разбиваем её на подзадачи, решая их по мере необходимости.
*   **Преимущества**:
    *   Проще писать и иногда более интуитивно понятно.
    *   Не вычисляются подзадачи, которые не нужны для конечного решения.
*   **Недостатки**:
    *   Возможность переполнения стека при глубокой рекурсии.
    *   Накладные расходы на рекурсивные вызовы.

### 2. Табуляция (Bottom-Up)
Итеративный подход, при котором все возможные подзадачи решаются "снизу вверх", начиная с самых маленьких и простых, и постепенно переходя к более сложным, заполняя таблицу (массив) с результатами.

*   **Идея**: Снизу вверх. Мы начинаем с базовых случаев и итеративно строим решения для всё больших подзадач.
*   **Преимущества**:
    *   Избегает рекурсии и связанных с ней накладных расходов.
    *   Лучше контролирует использование памяти.
*   **Недостатки**:
    *   Может потребовать вычисления всех подзадач, даже если некоторые из них не нужны для конечного ответа.
    *   Иногда сложнее продумать порядок вычислений.

---
## Примеры задач

Динамическое программирование применяется для решения широкого круга задач, например:

*   **Числа Фибоначчи**: Классический пример, демонстрирующий перекрывающиеся подзадачи.
    *   $F_n = F_{n-1} + F_{n-2}$
*   **Задача о рюкзаке**: Выбор предметов с максимальной ценностью, которые помещаются в рюкзак ограниченной вместимости.
*   **Наибольшая общая подпоследовательность**: Поиск самой длинной подпоследовательности, общей для двух или более последовательностей.
*   **Кратчайший путь в графе**: Например, алгоритм Флойда-Уоршелла для нахождения кратчайших путей между всеми парами вершин.
*   **Разбиение целого числа**: Подсчёт количества способов представления числа в виде суммы других чисел.
*   **Редакционное расстояние (расстояние Левенштейна)**: Минимальное количество операций (вставки, удаления, замены) для преобразования одной строки в другую.

---
## Шаги проектирования алгоритмов ДП

1.  **Определить подзадачи**: Как можно разбить исходную задачу на более мелкие, похожие подзадачи?
2.  **Найти рекуррентное соотношение**: Сформулировать, как решение текущей подзадачи зависит от решений меньших подзадач.
3.  **Определить базовые случаи**: Задачи, которые могут быть решены непосредственно, без дальнейшего разбиения.
4.  **Выбрать подход (мемоизация или табуляция)**: В зависимости от задачи и предпочтений.
5.  **Построить и реализовать решение**: Написать код, используя выбранный подход.

---
## Ограничения и когда не стоит использовать ДП

*   **Нет оптимальной подструктуры**: Если оптимальное решение подзадачи не ведёт к оптимальному решению основной задачи.
*   **Нет перекрывающихся подзадач**: Если каждая подзадача уникальна, использование ДП приведёт к тому, что подзадачи будут вычисляться только один раз, как в стандартной рекурсии, но с дополнительными накладными расходами на хранение. В таких случаях подходят [алгоритмы](Информатика/Алгоритмы%20и%20структуры%20данных/Алгоритм.md) "разделяй и властвуй".
*   **Слишком много состояний**: Если количество подзадач (состояний) слишком велико, чтобы хранить их решения в памяти.

---
## [Wiki](https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)