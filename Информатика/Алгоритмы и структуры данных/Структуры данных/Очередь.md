## Определение
**Очередь** (от англ. *queue* - очередь) - это абстрактный тип данных (АТД), представляющий собой упорядоченную коллекцию элементов, в которой добавление новых элементов происходит с одного конца, называемого **хвостом очереди (rear/back)**, а удаление элементов происходит с другого конца, называемого **головой очереди (front)**. Можно грубо назвать разновидностью [массива](Массив.md) (так как это коллекция элементов).

Очередь реализует принцип **FIFO (First In, First Out)** - «первым пришёл, первым ушёл». Это означает, что элемент, добавленный в очередь первым, будет первым извлечён из неё. Представьте себе очередь в магазине: кто первый встал в очередь, тот первым и обслуживается.

---
## Сложность и визуализация
--- start-multi-column: ExampleRegion1  
```column-settings  
number of columns: 2  
Border: false
Shadow: false
Column size: [60%, 39%]
```

-   **Вставка (enqueue):** $O(1)$
-   **Удаление (dequeue):** $O(1)$
-   **Чтение головы:** $O(1)$
-   **Проверка на пустоту:** $O(1)$
-   **Затраты памяти:** $O(n)$

--- end-column ---

![](q.gif)

--- end-multi-column

---
## Вариации реализации
### Массив
При реализации очереди на массиве мы используем вектор, у которого забираем первый элемент и вставляем новый элемент в конец. Однако это не оптимальная реализация, так как при удалении элемента из начала вектора требуется сдвиг всех оставшихся элементов, что занимает $O(n)$ времени. Кроме того, для работы с очередью нам необходим доступ только к первому и последнему элементам, а массив предоставляет избыточную функциональность. Для более эффективной реализации можно использовать двусвязанный список.

### [Двусвязанный список](Связанный%20список.md)
В двусвязанном списке мы храним указатели на голову (`head`) и хвост (`tail`) очереди. При удалении элемента (операция `dequeue`) перемещаем [[указатель]] `head` на следующий элемент, при вставке элемента (операция `enqueue`) добавляем новый элемент в конец и обновляем [[указатель]] `tail`. Обе операции выполняются за $O(1)$.

---
## Реализация на C++
```cpp
#include <deque>
#include <stdexcept>

template <typename T>
class Queue {
private:
    std::deque<T> data;

public:
    void enqueue(const T& value) {
        data.push_back(value);
    }
	
    T dequeue() {
        T front_element = data.front();
        data.pop_front();
        return front_element;
    }
	
    const T& front() const {
        return data.front();
    }
	
    const T& back() const {
        return data.back();
    }
	
    bool empty() const {
        return data.empty();
    }
	
    size_t size() const {
        return data.size();
    }
	
    void clear() {
        data.clear();
    }
};
```

---
## [Wiki](https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) [DSA](https://www.w3schools.com/dsa/dsa_data_queues.php)