## Определение
**Связанный список** (от англ. *linked list*) - это [[дерево]], представляющее собой упорядоченную коллекцию элементов. Каждый узел содержит данные и один или несколько указателей (ссылок) на другие узлы. В отличие от [массива](Массив.md), элементы связанного списка не хранятся в непрерывной области памяти, а могут располагаться в произвольных участках памяти, связанных между собой указателями.

Существует два основных типа связанных списков:
- **Односвязный список** - каждый узел содержит данные и [[указатель]] на следующий узел.
- **Двусвязный список** - каждый узел содержит данные, [[указатель]] на следующий узел и указатель на предыдущий узел.

---
## Сложность и визуализация
--- start-multi-column: ExampleRegion1  
```column-settings  
number of columns: 2  
Border: false
Shadow: false
```

**Односвязный список:**
-   **Вставка в начало:** $O(1)$
-   **Вставка в конец:** $O(n)$ или $O(1)$*
-   **Удаление из начала:** $O(1)$
-   **Удаление из конца:** $O(n)$
-   **Поиск элемента:** $O(n)$
-   **Доступ по индексу:** $O(n)$
-   **Затраты памяти:** $O(n)$

*при хранении указателя на хвост

--- end-column ---

**Двусвязанный список:**
-   **Вставка в начало:** $O(1)$
-   **Вставка в конец:** $O(1)$*
-   **Удаление из начала:** $O(1)$
-   **Удаление из конца:** $O(1)$*
-   **Поиск элемента:** $O(n)$
-   **Доступ по индексу:** $O(n)$
-   **Затраты памяти:** $O(n)$

*при хранении указателя на хвост

--- end-multi-column
![](linked_list.png)

---
## Реализация односвязного списка на C++
```cpp
#pragma once
#include <cstddef>
#include <stdexcept>

template <typename T>
struct Node {
    T data;
    Node* prev;
    Node* next;

    Node(const T& value, Node* p = nullptr, Node* n = nullptr)
        : data(value), prev(p), next(n) {}
};

template <typename T>
class LinkedList {
private:
    Node<T>* head;
    Node<T>* tail;
    size_t list_size;
	
public:
    LinkedList() : head(nullptr), tail(nullptr), list_size(0) {}
    ~LinkedList() { clear(); }
	
    LinkedList(const LinkedList&) = delete;
    LinkedList& operator=(const LinkedList&) = delete;
	
    void push_front(const T& value) {
        Node<T>* new_node = new Node<T>(value, nullptr, head);
        if (head) head->prev = new_node;
        head = new_node;
        if (!tail) tail = head;
        list_size++;
    }
	
    void push_back(const T& value) {
        Node<T>* new_node = new Node<T>(value, tail, nullptr);
        if (tail) tail->next = new_node;
        tail = new_node;
        if (!head) head = tail;
        list_size++;
    }
	
    void pop_front() {
        if (!head) throw std::runtime_error("List is empty");
        Node<T>* temp = head;
        head = head->next;
        if (head) head->prev = nullptr;
        else tail = nullptr;
        delete temp;
        list_size--;
    }
	
    void pop_back() {
        if (!tail) throw std::runtime_error("List is empty");
        Node<T>* temp = tail;
        tail = tail->prev;
        if (tail) tail->next = nullptr;
        else head = nullptr;
        delete temp;
        list_size--;
    }
	
    const T& front() const {
        if (!head) throw std::runtime_error("List is empty");
        return head->data;
    }
	
    const T& back() const {
        if (!tail) throw std::runtime_error("List is empty");
        return tail->data;
    }
	
    bool empty() const { return list_size == 0; }
    size_t size() const { return list_size; }
	
    void clear() {
        Node<T>* current = head;
        while (current) {
            Node<T>* next = current->next;
            delete current;
            current = next;
        }
        head = tail = nullptr;
        list_size = 0;
    }
};

```

---
## Преимущества и недостатки
### Преимущества
- Динамический размер - не нужно заранее знать количество элементов
- Эффективная вставка и удаление элементов в начале списка $O(1)$
- Отсутствие необходимости перемещения элементов при вставке/удалении

### Недостатки
- Нет прямого доступа к элементам по индексу $O(n)$
- Дополнительные затраты памяти на хранение указателей
- Плохая локальность данных в памяти (медленнее работа с кэшем процессора)

---
## [Wiki](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA) [DSA](https://www.w3schools.com/dsa/dsa_theory_linkedlists.php)