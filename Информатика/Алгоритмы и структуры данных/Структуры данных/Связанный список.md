## Определение
**Связанный список** (от англ. *linked list*) — это структура данных, представляющая собой упорядоченную коллекцию элементов, называемых **узлами (nodes)**. Каждый узел содержит данные и один или несколько указателей (ссылок) на другие узлы. В отличие от [массива](Массив.md), элементы связанного списка не хранятся в непрерывной области памяти, а могут располагаться в произвольных участках памяти, связанных между собой указателями.

Существует два основных типа связанных списков:
- **Односвязный список** — каждый узел содержит данные и [[указатель]] на следующий узел.
- **Двусвязный список** — каждый узел содержит данные, [[указатель]] на следующий узел и указатель на предыдущий узел.

---
## Сложность и визуализация
--- start-multi-column: ExampleRegion1  
```column-settings  
number of columns: 2  
Border: false
Shadow: false
```

**Односвязный список:**
-   **Вставка в начало:** $O(1)$
-   **Вставка в конец:** $O(n)$ или $O(1)$*
-   **Удаление из начала:** $O(1)$
-   **Удаление из конца:** $O(n)$
-   **Поиск элемента:** $O(n)$
-   **Доступ по индексу:** $O(n)$
-   **Затраты памяти:** $O(n)$

*при хранении указателя на хвост

--- end-column ---

**Двусвязанный список:**
-   **Вставка в начало:** $O(1)$
-   **Вставка в конец:** $O(1)$*
-   **Удаление из начала:** $O(1)$
-   **Удаление из конца:** $O(1)$*
-   **Поиск элемента:** $O(n)$
-   **Доступ по индексу:** $O(n)$
-   **Затраты памяти:** $O(n)$

*при хранении указателя на хвост

--- end-multi-column
![](linked_list.png)

---
## Реализация односвязного списка на C++
```cpp
#include <stdexcept>

template <typename T>
class LinkedList {
private:
    struct Node {
        T data;
        Node* next;
        
        Node(const T& value) : data(value), next(nullptr) {}
    };
    
    Node* head;
    Node* tail;
    size_t list_size;

public:
    LinkedList() : head(nullptr), tail(nullptr), list_size(0) {}
    
    ~LinkedList() {
        clear();
    }
    
    void push_front(const T& value) {
        Node* new_node = new Node(value);
        new_node->next = head;
        head = new_node;
        
        if (tail == nullptr) {
            tail = head;
        }
        
        list_size++;
    }
    
    void push_back(const T& value) {
        Node* new_node = new Node(value);
        
        if (tail == nullptr) {
            head = tail = new_node;
        } else {
            tail->next = new_node;
            tail = new_node;
        }
        
        list_size++;
    }
    
    void pop_front() {
        if (head == nullptr) {
            throw std::runtime_error("List is empty");
        }
        
        Node* temp = head;
        head = head->next;
        delete temp;
        
        if (head == nullptr) {
            tail = nullptr;
        }
        
        list_size--;
    }
    
    const T& front() const {
        if (head == nullptr) {
            throw std::runtime_error("List is empty");
        }
        return head->data;
    }
    
    const T& back() const {
        if (tail == nullptr) {
            throw std::runtime_error("List is empty");
        }
        return tail->data;
    }
    
    bool empty() const {
        return head == nullptr;
    }
    
    size_t size() const {
        return list_size;
    }
    
    void clear() {
        while (head != nullptr) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
        tail = nullptr;
        list_size = 0;
    }
};
```

---
## Преимущества и недостатки
### Преимущества
- Динамический размер — не нужно заранее знать количество элементов
- Эффективная вставка и удаление элементов в начале списка $O(1)$
- Отсутствие необходимости перемещения элементов при вставке/удалении

### Недостатки
- Нет прямого доступа к элементам по индексу $O(n)$
- Дополнительные затраты памяти на хранение указателей
- Плохая локальность данных в памяти (медленнее работа с кэшем процессора)

---
## [Wiki](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA) [DSA](https://www.w3schools.com/dsa/dsa_theory_linkedlists.php)