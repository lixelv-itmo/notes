## Определение
**Аллокация памяти** — это процесс выделения и освобождения памяти для хранения данных программы. В C++ существует два основных типа памяти: **стек** и **куча**.

---
## Стек
### Характеристики
- Автоматическое управление памятью
- Быстрое выделение и освобождение
- Ограниченный размер (обычно 1-8 МБ)
- Переменные освобождаются автоматически при выходе из области видимости

### Пример
```cpp
void function() {
    int x = 10;           // выделяется на стеке
    double arr[100];      // массив на стеке
    std::string s = "hi"; // объект на стеке
    
    // при выходе из функции вся память автоматически освобождается
}
```

### Что хранится на стеке
- Локальные переменные
- Параметры функций
- Адреса возврата функций
- Небольшие объекты

---
## Куча
### Характеристики
- Ручное управление памятью (`new` / `delete`)
- Медленнее стека
- Ограничен только доступной оперативной памятью
- Память остаётся выделенной до явного освобождения
- Риск утечек памяти при неправильном использовании

### Синтаксис
```cpp
// Выделение памяти
int* ptr = new int(42);              // один элемент
int* arr = new int[100];             // массив
MyClass* obj = new MyClass();        // объект класса

// Освобождение памяти
delete ptr;      // освобождение одного элемента
delete[] arr;    // освобождение массива
delete obj;      // освобождение объекта
```

### Пример
```cpp
void heapExample() {
    int* p = new int(100);        // выделение в куче
    
    // используем указатель
    std::cout << *p << std::endl; // 100
    
    delete p;                     // ОБЯЗАТЕЛЬНО освобождаем память!
}
```

---
## Сравнение стека и кучи

| Характеристика | Стек | Куча |
|---------------|------|------|
| Скорость | Быстро | Медленнее |
| Размер | Ограничен (~1-8 МБ) | Ограничен RAM |
| Управление | Автоматическое | Ручное |
| Фрагментация | Нет | Возможна |
| Время жизни | До выхода из scope | До явного delete |
| Синтаксис | `int x = 10;` | `int* x = new int(10);` |

---
## Проблемы с динамической памятью

### Утечка памяти (Memory Leak)
```cpp
void leak() {
    int* p = new int(42);
    // забыли вызвать delete!
}  // память не освобождена — утечка!
```

### Висячий указатель (Dangling Pointer)
```cpp
int* p = new int(42);
delete p;
// p всё ещё хранит адрес удалённой памяти
*p = 100;  // ОШИБКА! Обращение к освобождённой памяти
```

### Двойное освобождение
```cpp
int* p = new int(42);
delete p;
delete p;  // ОШИБКА! Повторное освобождение
```

---
## Умные указатели (Smart Pointers)
Современный C++ предоставляет умные указатели для автоматического управления памятью в куче.

```cpp
#include <memory>

// unique_ptr — единственный владелец
std::unique_ptr<int> p1(new int(42));
std::unique_ptr<int> p2 = std::make_unique<int>(100);  // C++14

// shared_ptr — разделяемое владение
std::shared_ptr<int> s1 = std::make_shared<int>(42);
std::shared_ptr<int> s2 = s1;  // оба указывают на одну память

// память освобождается автоматически!
```

---
## Когда использовать что

### Используйте стек:
- Для небольших объектов фиксированного размера
- Когда размер известен на этапе компиляции
- Для временных переменных
- По умолчанию

### Используйте кучу:
- Для больших объектов
- Когда размер определяется во время выполнения
- Когда объект должен пережить функцию
- Для полиморфизма через указатели

---
## Пример смешанного использования
```cpp
#include <iostream>

struct Node {
    int data;
    Node* next;  // указатель хранится на стеке, указывает на кучу
};

int main() {
    // Переменные на стеке
    int x = 10;
    int arr[5];
    
    // Динамические данные в куче
    int* dynamicArr = new int[1000000];  // большой массив
    Node* head = new Node{1, nullptr};
    
    // Используем...
    
    // Освобождаем кучу
    delete[] dynamicArr;
    delete head;
    
    // Стековые переменные освобождаются автоматически
    return 0;
}
```

---

## [Wiki](https://ru.wikipedia.org/wiki/Виртуальная_память) [W3](https://www.w3schools.com/c/c_memory_management.php)