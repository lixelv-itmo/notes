```
Binary Relations
Discrete Math, Fall 2025
Konstantin Chukharev
Set
Theory
â€¢ Operations & laws
â€¢ Power sets
â€¢ Russellâ€™s paradox
â€¢ ZFC axioms
â€¢ Cartesian products
â€¢ Cardinality
Binary
Relations
â€¢ Relation properties
â€¢ Equivalence relations
â€¢ Functions
â€¢ Partial orders
â€¢ Lattices
â€¢ Well-orders
Boolean
Algebra
â€¢ Truth tables & laws
â€¢ Logic circuits
â€¢ Normal forms
â€¢ Karnaugh maps
â€¢ Binary Decision
Diagrams (BDDs)
Formal
Logic
â€¢ Syntax & semantics
â€¢ Natural deduction
â€¢ Soundness &
completeness
â€¢ Categorical logic
â€¢ First-order logic
Relations
â€œIn mathematics you donâ€™t understand things. You just get used to them.â€
â€” John von Neumann
RenÃ© Descartes Ã‰variste Galois Ernst SchrÃ¶der Michael Rabin Herbert Wilf
What is a Relation?
Relations capture connections between elements of sets.
Example (Everyday examples):
â€¢ â€œis less thanâ€ relates numbers: 3 is related to 5 because 3 < 5
â€¢ â€œis a parent ofâ€ relates people: Alice is related to Bob if Alice is Bobâ€™s parent
â€¢ â€œdividesâ€ relates integers: 2 is related to 6 because 2 | 6
Intuition: A relation tells us which pairs of elements are connected.
Definition 1: A binary relation ğ‘… from set ğ´ to set ğµ is a subset of the Cartesian product:
ğ‘… âŠ† ğ´ Ã— ğµ
Each ordered pair âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘… means â€œğ‘ is related to ğ‘.â€
4 / 246
Notation for Relations
Notation: If ğ‘… âŠ† ğ´ Ã— ğµ, we write:
â€¢ ğ‘ ğ‘… ğ‘ to mean âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘… (element ğ‘ is related to element ğ‘)
â€¢ ğ‘ ğ‘… ğ‘ to mean âŸ¨ğ‘, ğ‘âŸ© âˆ‰ ğ‘… (element ğ‘ is not related to element ğ‘)
Example: Let ğ‘… = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨1, 3âŸ©} be a relation on naturals.
â€¢ We can write 1 ğ‘… 2 instead of âŸ¨1, 2âŸ© âˆˆ ğ‘…
â€¢ We can write 2 ğ‘… 1 instead of âŸ¨2, 1âŸ© âˆ‰ ğ‘…
Key insight: Order matters! ğ‘ ğ‘… ğ‘ and ğ‘ ğ‘… ğ‘ are different statements.
5 / 246
Types of Relations
Definition 2: A binary relation ğ‘… âŠ† ğ´ Ã— ğµ is:
â€¢ Heterogeneous if ğ´ and ğµ are different sets
â€¢ Homogeneous if ğ´ = ğµ (we write ğ‘… âŠ† ğ‘€2)
Example (Heterogeneous relation): Let Students = {Alice, Bob} and Subjects = {Math, Algorithms}.
The relation â€œlikesâ€ (between students and subjects) might be:
ğ‘… = {âŸ¨Alice, MathâŸ©, âŸ¨Alice, AlgorithmsâŸ©, âŸ¨Bob, AlgorithmsâŸ©}
We write â€œAlice ğ‘… Mathâ€ to denote that â€œAlice likes Mathâ€.
Example (Homogeneous relation): The â€œless thanâ€ relation on â„•:
ğ‘… = {âŸ¨ğ‘›, ğ‘˜âŸ© | ğ‘›, ğ‘˜ âˆˆ â„• and ğ‘› < ğ‘˜} âŠ† â„•2
For instance: 2 ğ‘… 3 (since 2 < 3) and 3 ğ‘… 2 (since not 3 < 2).
6 / 246
Visualizing Relations: Directed Graphs
Relations can be visualized as graphs, making their structure easier to understand.
Definition 3: A homogeneous relation ğ‘… âŠ† ğ‘€2 is represented as a directed graph:
â€¢ Each element of ğ‘€ becomes a vertex
â€¢ Draw edge ğ‘¥ â†’ ğ‘¦ whenever ğ‘¥ ğ‘… ğ‘¦ (i.e., âŸ¨ğ‘¥, ğ‘¦âŸ© âˆˆ ğ‘…)
Example: Relation ğ‘… = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨1, 3âŸ©} on ğ‘€ = {1, 2, 3}:
3
1 ğ‘… 3
2 ğ‘… 3
1 2
1 ğ‘… 2
7 / 246
Visualizing Relations: Bipartite Graphs
Heterogeneous relations connect elements from two different sets.
Definition 4: A heterogeneous relation ğ‘… âŠ† ğ´ Ã— ğµ can be represented as a bipartite graph:
â€¢ Left partition: vertices for elements of ğ´
â€¢ Right partition: vertices for elements of ğµ
â€¢ Draw edge ğ‘ â†’ ğ‘ whenever ğ‘ ğ‘… ğ‘ (i.e., âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘…)
Example: Animals ğ´ = {ğŸ‡,ğŸˆï¸,ğŸ•ï¸} and food ğµ = {ğŸ¥•, ğŸŸï¸}. Relation ğ‘…: â€œlikes to eatâ€.
ğŸ‡
ğŸ¥•
ğŸˆï¸
ğŸŸï¸
ğ‘… âŠ† ğ´ Ã— ğµ
Animals (ğ´) Food (ğµ)
ğŸ•ï¸
8 / 246
Matrix Representation
Definition 5: A relation ğ‘… âŠ† ğ´ Ã— ğµ with ğ´ = {ğ‘1, â€¦, ğ‘ğ‘š} and ğµ = {ğ‘1, â€¦, ğ‘ğ‘›} is represented by an
ğ‘š Ã— ğ‘› boolean matrix âŸ¦ğ‘…âŸ§:
âŸ¦ğ‘…âŸ§[ğ‘–, ğ‘—] = {1 if ğ‘ğ‘– ğ‘… ğ‘ğ‘—
0 if ğ‘ğ‘– ğ‘… ğ‘ğ‘—
Example: Let ğ´ = {ğ‘, ğ‘, ğ‘}, ğµ = {ğ‘¥, ğ‘¦}, and ğ‘… = {âŸ¨ğ‘, ğ‘¥âŸ©, âŸ¨ğ‘, ğ‘¥âŸ©, âŸ¨ğ‘, ğ‘¦âŸ©}.
Matrix representation with rows = ğ´ and columns = ğµ:
âŸ¦ğ‘…âŸ§ =
[
1
1
0
0
0
1]
âŸº
{
ğ‘ ğ‘… ğ‘¥, ğ‘ ğ‘… ğ‘¦
ğ‘ ğ‘… ğ‘¥, ğ‘ ğ‘… ğ‘¦
ğ‘ ğ‘… ğ‘¥, ğ‘ ğ‘… ğ‘¦
Why matrices? Matrix operations (multiply, transpose) match relation operations (compose, inverse).
9 / 246
Special Relations
Definition 6: For any set ğ‘€, we have:
â€¢ Empty relation: âˆ… âŠ† ğ‘€2 â€” No pairs at all; nothing is related to anything.
â€¢ Identity relation: ğ¼ğ‘€ = {âŸ¨ğ‘¥, ğ‘¥âŸ© | ğ‘¥ âˆˆ ğ‘€} â€” Each element is related only to itself.
â€¢ Universal relation: ğ‘ˆğ‘€ = ğ‘€2 â€” All possible pairs; everything is related to everything.
Example: For ğ‘€ = {ğ‘, ğ‘, ğ‘}:
â€¢ Empty: âˆ… (no relations)
â€¢ Identity: ğ¼ğ‘€ = {âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©} (3 pairs on diagonal)
â€¢ Universal: ğ‘ˆğ‘€ = {âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©} (all 32 = 9 pairs)
Matrix representations:
âŸ¦âˆ…âŸ§ =
[
0
0
0
0
0
0
0
0
0] âŸ¦ğ¼ğ‘€âŸ§ =
[
1
0
0
0
1
0
0
0
1] âŸ¦ğ‘ˆğ‘€âŸ§ =
[
1
1
1
1
1
1
1
1
1]
10 / 246
Set Operations on Relations
Since relations are sets of pairs, we can apply standard set operations.
Definition 7: For relations ğ‘…, ğ‘† âŠ† ğ´ Ã— ğµ:
â€¢ Union: ğ‘… âˆª ğ‘† = {âŸ¨ğ‘, ğ‘âŸ© | âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘… âˆ¨ âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘†}
â€¢ Intersection: ğ‘… âˆ© ğ‘† = {âŸ¨ğ‘, ğ‘âŸ© | âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘… âˆ§ âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘†}
â€¢ Complement: ğ‘… = (ğ´ Ã— ğµ) âˆ– ğ‘… = {âŸ¨ğ‘, ğ‘âŸ© | âŸ¨ğ‘, ğ‘âŸ© âˆ‰ ğ‘…}
Example: Let ğ‘… = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©} and ğ‘† = {âŸ¨1, 2âŸ©, âŸ¨3, 4âŸ©} on â„•.
â€¢ ğ‘… âˆª ğ‘† = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨3, 4âŸ©} (all pairs from either relation)
â€¢ ğ‘… âˆ© ğ‘† = {âŸ¨1, 2âŸ©} (only common pairs)
â€¢ If we restrict to ğ‘€ = {1, 2, 3}, then ğ‘… = {âŸ¨1, 1âŸ©, âŸ¨1, 3âŸ©, âŸ¨2, 1âŸ©, âŸ¨2, 2âŸ©, âŸ¨3, 1âŸ©, âŸ¨3, 2âŸ©, âŸ¨3, 3âŸ©}
Matrix view: Union = OR, Intersection = AND, Complement = NOT (element-wise on matrices).
11 / 246
Inverse Relation
Definition 8: For ğ‘… âŠ† ğ´ Ã— ğµ, the inverse (or converse, or dual) relation is:
ğ‘…âˆ’1 = {âŸ¨ğ‘, ğ‘âŸ© | âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘…} âŠ† ğµ Ã— ğ´
Note: ğ‘…âˆ’1 reverses all connections. If ğ‘ ğ‘… ğ‘, then ğ‘ ğ‘…âˆ’1 ğ‘.
Note: Other notations: ğ‘…ğ‘‡ (transpose), ğ‘…âˆ (converse), ğ‘…âš¬ (reciprocal).
Example:
â€¢ If ğ‘… = {âŸ¨1, ğ‘¥âŸ©, âŸ¨2, ğ‘¦âŸ©, âŸ¨2, ğ‘§âŸ©}, then ğ‘…âˆ’1 = {âŸ¨ğ‘¥, 1âŸ©, âŸ¨ğ‘¦, 2âŸ©, âŸ¨ğ‘§, 2âŸ©}.
â€¢ For order relations:
â€£ (<)âˆ’1 = (>) (inverse of â€œless thanâ€ is â€œgreater thanâ€)
â€£ (â‰¤)âˆ’1 = (â‰¥) (inverse of â€œless or equalâ€ is â€œgreater or equalâ€)
â€¢ For the â€œparent ofâ€ relation: (parent of)âˆ’1 = â€œchild ofâ€
Matrix view: âŸ¦ğ‘…âˆ’1âŸ§ is the transpose of âŸ¦ğ‘…âŸ§.
12 / 246
Properties of Relations
Reflexivity
A relation is reflexive if every element is related to itself.
Definition 9: ğ‘… âŠ† ğ‘€2 is reflexive if:
âˆ€ğ‘¥ âˆˆ ğ‘€. ğ‘¥ ğ‘… ğ‘¥
Examples:
â€¢ Reflexive: â‰¤,
=, â€œis the same age asâ€
â€¢ Not reflexive: <, â‰ , â€œis parent ofâ€
Graph view: Every vertex has a self-loop.
Matrix view: All diagonal entries are 1.
14 / 246
Symmetry
A relation is symmetric if the relation goes both ways.
Definition 10: ğ‘… âŠ† ğ‘€2 is symmetric if:
âˆ€ğ‘¥, ğ‘¦ âˆˆ ğ‘€. (ğ‘¥ ğ‘… ğ‘¦) â†’ (ğ‘¦ ğ‘… ğ‘¥)
Example:
â€¢ Symmetric: =, â€œis sibling ofâ€, â€œis married toâ€
â€¢ Not symmetric: â‰¤, â€œis parent ofâ€, â€œlikesâ€
Graph view: If thereâ€™s an edge ğ‘¥ â†’ ğ‘¦, thereâ€™s also ğ‘¦ â†’ ğ‘¥.
Matrix view: Matrix equals its transpose.
15 / 246
Transitivity
A relation is transitive if connections chain together.
Definition 11: ğ‘… âŠ† ğ‘€2 is transitive if:
âˆ€ğ‘¥, ğ‘¦, ğ‘§ âˆˆ ğ‘€. (ğ‘¥ ğ‘… ğ‘¦ âˆ§ ğ‘¦ ğ‘… ğ‘§) â†’ (ğ‘¥ ğ‘… ğ‘§)
Example:
â€¢ Transitive: â‰¤,
=, â€œis ancestor ofâ€
â€¢ Not transitive: â€œis parent ofâ€ (parent of parent is grandparent, not parent)
Intuition: If you can reach ğ‘§ from ğ‘¥ through ğ‘¦, you can reach ğ‘§ directly from ğ‘¥.
16 / 246
Irreflexivity
A relation is irreflexive if no element is related to itself.
Definition 12: ğ‘… âŠ† ğ‘€2 is irreflexive if:
âˆ€ğ‘¥ âˆˆ ğ‘€. ğ‘¥ ğ‘… ğ‘¥
Example:
â€¢ Irreflexive: <, â‰ , â€œis parent ofâ€
â€¢ Not irreflexive: â‰¤,
=
Note: Irreflexive is not the same as â€œnot reflexiveâ€! A relation can be neither reflexive nor irreflexive.
17 / 246
Antisymmetry
A relation is antisymmetric if different elements canâ€™t be mutually related.
Definition 13: ğ‘… âŠ† ğ‘€2 is antisymmetric if:
âˆ€ğ‘¥, ğ‘¦ âˆˆ ğ‘€. (ğ‘¥ ğ‘… ğ‘¦ âˆ§ ğ‘¦ ğ‘… ğ‘¥) â†’ (ğ‘¥ = ğ‘¦)
Note: Alternative definition:
âˆ€ğ‘¥, ğ‘¦ âˆˆ ğ‘€. (ğ‘¥ â‰  ğ‘¦) â†’ (ğ‘¥ ğ‘… ğ‘¦ â†’ ğ‘¦ ğ‘… ğ‘¥)
Example:
â€¢ Antisymmetric: â‰¤, âŠ†, â€œdividesâ€ (on positive integers)
â€¢ Not antisymmetric: â€œis sibling ofâ€, â€œis friend ofâ€
Intuition: At most one direction exists between distinct elements.
18 / 246
Asymmetry
A relation is asymmetric if it never goes both ways.
Definition 14: ğ‘… âŠ† ğ‘€2 is asymmetric if:
âˆ€ğ‘¥, ğ‘¦ âˆˆ ğ‘€. (ğ‘¥ ğ‘… ğ‘¦) â†’ (ğ‘¦ ğ‘… ğ‘¥)
Example:
â€¢ Asymmetric: <, â€œis parent ofâ€
â€¢ Not asymmetric: â‰¤,
=
Note: Asymmetric = irreflexive + antisymmetric. Asymmetry is the strongest directional property.
19 / 246
Properties: Important Notes
Note: Properties are not always opposites:
â€¢ Reflexive vs irreflexive: A relation can be neither (e.g., ğ‘… = {âŸ¨1, 1âŸ©, âŸ¨1, 2âŸ©} on ğ‘€ = {1, 2})
â€¢ Symmetric vs antisymmetric: A relation can be both (e.g., identity ğ¼ğ‘€)
Note: Empty set edge case: On ğ‘€ = âˆ…, the empty relation is vacuously1 reflexive, irreflexive, symmetric,
antisymmetric, asymmetric, and transitive!
Example (Combining properties): Common combinations:
â€¢ Equivalence relation: reflexive + symmetric + transitive (e.g.,
â€¢ Partial order: reflexive + antisymmetric + transitive (e.g., â‰¤)
â€¢ Strict order: irreflexive + antisymmetric + transitive (e.g., <)
=)
1A universal statement â€œâˆ€ğ‘¥ âˆˆ âˆ…. ğ‘ƒ(ğ‘¥)â€ is true because there are no counterexamples.
20 / 246
Additional Properties
Definition 15: A relation ğ‘… âŠ† ğ‘€2 is:
â€¢ Coreflexive: If ğ‘… âŠ† ğ¼ğ‘€ (only self-loops are allowed).
âˆ€ğ‘¥, ğ‘¦ âˆˆ ğ‘€. (ğ‘¥ ğ‘… ğ‘¦) â†’ (ğ‘¥ = ğ‘¦)
â€¢ Right Euclidean: If ğ‘¥ relates to both ğ‘¦ and ğ‘§, then ğ‘¦ and ğ‘§ are related.
âˆ€ğ‘¥, ğ‘¦, ğ‘§ âˆˆ ğ‘€. (ğ‘¥ ğ‘… ğ‘¦ âˆ§ ğ‘¥ ğ‘… ğ‘§) â†’ (ğ‘¦ ğ‘… ğ‘§)
â€¢ Left Euclidean: If both ğ‘¦ and ğ‘§ relate to ğ‘¥, then they relate to each other.
âˆ€ğ‘¥, ğ‘¦, ğ‘§ âˆˆ ğ‘€. (ğ‘¦ ğ‘… ğ‘¥ âˆ§ ğ‘§ ğ‘… ğ‘¥) â†’ (ğ‘¦ ğ‘… ğ‘§)
Example:
â€¢ Identity relation ğ¼ğ‘€ is coreflexive (and any subset of ğ¼ğ‘€)
â€¢ Equality â€œ=â€ is both left and right Euclidean
â€¢ Equivalence relations are Euclidean in both directions
21 / 246
Equivalence Relations
Equivalence Relations
Definition 16: A relation ğ‘… âŠ† ğ‘€2 is an equivalence relation if it is reflexive, symmetric and transitive.
Example (Equality): The identity relation ğ¼ğ‘€ = {âŸ¨ğ‘¥, ğ‘¥âŸ© | ğ‘¥ âˆˆ ğ‘€} is an equivalence relation on any set ğ‘€.
Note: The identity relation is just the common equality relation â€œ=â€.
Verification:
â€¢ Reflexive: ğ‘¥ ğ¼ğ‘€ ğ‘¥ for all ğ‘¥ âˆˆ ğ‘€ (by definition of ğ¼ğ‘€) âœ“
â€¢ Symmetric: If ğ‘¥ ğ¼ğ‘€ ğ‘¦, then ğ‘¥ = ğ‘¦, thus ğ‘¦ = ğ‘¥, so ğ‘¦ ğ¼ğ‘€ ğ‘¥ âœ“
â€¢ Transitive: If ğ‘¥ ğ¼ğ‘€ ğ‘¦ and ğ‘¦ ğ¼ğ‘€ ğ‘§, then ğ‘¥ = ğ‘¦ = ğ‘§, so ğ‘¥ ğ¼ğ‘€ ğ‘§ âœ“
This is the â€œfinestâ€ possible equivalence relation â€” it distinguishes every element.
23 / 246
Equivalence Classes
Definition 17: Let ğ‘… âŠ† ğ‘€2 be an equivalence relation on a set ğ‘€. The equivalence class of an
element ğ‘¥ âˆˆ ğ‘€ under ğ‘… is the set of all elements related to ğ‘¥:
[ğ‘¥]ğ‘… = {ğ‘¦ âˆˆ ğ‘€ | ğ‘¥ ğ‘… ğ‘¦}
Example (Equality): For the identity relation ğ¼ğ‘€ on set ğ‘€ = {ğ‘, ğ‘, ğ‘}:
â€¢ [ğ‘]ğ¼ğ‘€
â€¢ [ğ‘]ğ¼ğ‘€
â€¢ [ğ‘]ğ¼ğ‘€
= {ğ‘} (only ğ‘ is equal to ğ‘)
= {ğ‘} (only ğ‘ is equal to ğ‘)
= {ğ‘} (only ğ‘ is equal to ğ‘)
Each element forms its own equivalence class under equality.
24 / 246
Examples of Equivalence Relations
Example (Modular arithmetic): For any positive integer ğ‘›, congruence modulo ğ‘› on â„¤ is defined by:
ğ‘ â‰¡ ğ‘ (mod ğ‘›) iff ğ‘› | (ğ‘ âˆ’ ğ‘)
Verification:
â€¢ Reflexive: ğ‘ â‰¡ ğ‘ (mod ğ‘›) since ğ‘› | (ğ‘ âˆ’ ğ‘) âŸº ğ‘› | 0 âœ“
â€¢ Symmetric: If ğ‘ â‰¡ ğ‘ (mod ğ‘›), then ğ‘› | (ğ‘ âˆ’ ğ‘) âŸº ğ‘› | (ğ‘ âˆ’ ğ‘), thus ğ‘ â‰¡ ğ‘ (mod ğ‘›) âœ“
â€¢ Transitive: If ğ‘ â‰¡ ğ‘ (mod ğ‘›) and ğ‘ â‰¡ ğ‘ (mod ğ‘›), then ğ‘› | (ğ‘ âˆ’ ğ‘) and ğ‘› | (ğ‘ âˆ’ ğ‘), so
ğ‘› | ((ğ‘ âˆ’ ğ‘) + (ğ‘ âˆ’ ğ‘)) âŸº ğ‘› | (ğ‘ âˆ’ ğ‘), thus ğ‘ â‰¡ ğ‘ (mod ğ‘›) âœ“
Equivalence classes (remainders): Let ğ‘› = 5 and ğ‘€ = {0, 1, â€¦, 9}.
â€¢ [0]â‰¡
= {0, 5} = {ğ‘¥ âˆˆ ğ‘€ | ğ‘¥ â‰¡ 0 (mod 5)}
â€¢ [1]â‰¡
= {1, 6} = {ğ‘¥ âˆˆ ğ‘€ | ğ‘¥ â‰¡ 1 (mod 5)}
â€¢ [2]â‰¡
= {2, 7} = {ğ‘¥ âˆˆ ğ‘€ | ğ‘¥ â‰¡ 2 (mod 5)}
â€¢ [3]â‰¡
= {3, 8} = {ğ‘¥ âˆˆ ğ‘€ | ğ‘¥ â‰¡ 3 (mod 5)}
â€¢ [4]â‰¡
= {4, 9} = {ğ‘¥ âˆˆ ğ‘€ | ğ‘¥ â‰¡ 4 (mod 5)}
25 / 246
Examples of Equivalence Relations [2]
Example (Same absolute value): On ğ‘€ = {âˆ’3,
âˆ’2,
ğ‘¥ ğ‘… ğ‘¦ iff |ğ‘¥| = |ğ‘¦|
âˆ’1, 0, 1, 2, 3}, define relation ğ‘… by:
Verification:
â€¢ Reflexive: |ğ‘¥| = |ğ‘¥| for all ğ‘¥ âœ“
â€¢ Symmetric: If |ğ‘¥| = |ğ‘¦|, then |ğ‘¦| = |ğ‘¥| âœ“
â€¢ Transitive: If |ğ‘¥| = |ğ‘¦| and |ğ‘¦| = |ğ‘§|, then |ğ‘¥| = |ğ‘§| âœ“
Equivalence classes:
â€¢ [0]ğ‘… = {0}
â€¢ [1]ğ‘… = [âˆ’1]ğ‘… = {âˆ’1, 1}
â€¢ [2]ğ‘… = [âˆ’2]ğ‘… = {âˆ’2, 2}
â€¢ [3]ğ‘… = [âˆ’3]ğ‘… = {âˆ’3, 3}
Each positive number is equivalent to its negative counterpart.
26 / 246
Examples of Equivalence Relations [3]
Example (Same string length): On the set of all finite strings Î£âˆ— over alphabet Î£, define:
ğ‘ 1 ğ‘… ğ‘ 2 iff |ğ‘ 1| = |ğ‘ 2|
where |ğ‘ | denotes the length of string ğ‘ .
Verification:
â€¢ Reflexive: Every string has the same length as itself âœ“
â€¢ Symmetric: If two strings have the same length, the relation is symmetric âœ“
â€¢ Transitive: If |ğ‘ 1| = |ğ‘ 2| and |ğ‘ 2| = |ğ‘ 3|, then |ğ‘ 1| = |ğ‘ 3| âœ“
Equivalence classes: [ğ‘ ]ğ‘… = {ğ‘¡ âˆˆ Î£âˆ— | |ğ‘¡| = |ğ‘ |}
For example, over Î£ = {ğ‘, ğ‘}:
â€¢ [ğœ€]ğ‘… = {ğœ€} (empty string)
â€¢ [a]ğ‘… = {a, b} (all strings of length 1)
â€¢ [ab]ğ‘… = {aa, ab, ba, bb} (all strings of length 2)
27 / 246
Examples of Equivalence Relations [4]
Example (Living in the same city): Let ğ‘ƒ be the set of people, and define relation ğ‘… by:
ğ‘1 ğ‘… ğ‘2 iff ğ‘1 and ğ‘2 live in the same city
Verification:
â€¢ Reflexive: Every person lives in the same city as themselves âœ“
â€¢ Symmetric: If person A and B live in the same city, then B and A live in the same city âœ“
â€¢ Transitive: If A and B live in the same city, and B and C do so, then A and C live in the same city âœ“
Equivalence classes: Each equivalence class consists of all people living in the same city.
â€¢ [Alice]ğ‘… = all people living in Aliceâ€™s city
â€¢ This naturally partitions the population by cities
Application: This relation captures a common social grouping based on location.
28 / 246
Examples of Equivalence Relations [5]
Example (Similarity of triangles): Let ğ‘‡ be the set of all triangles in the plane. Define relation âˆ¼ by:
â–³1 âˆ¼ â–³2 iff â–³1 and â–³2 are similar2
Verification:
â€¢ Reflexive: Every triangle is similar to itself âœ“
â€¢ Symmetric: If triangle ğ´ is similar to triangle ğµ, then triangle ğµ is similar to triangle ğ´ âœ“
â€¢ Transitive: If ğ´ âˆ¼ ğµ and ğµ âˆ¼ ğ¶, then ğ´ âˆ¼ ğ¶ (similarity is transitive) âœ“
Equivalence classes: Each class consists of all triangles with the same shape (but possibly different sizes).
â€¢ All equilateral triangles form one equivalence class
â€¢ All right triangles with legs in ratio 3:4:5 form another equivalence class
Geometric significance: This relation captures the concept of â€œsame shape, different size.â€
2Two triangles are similar if their corresponding angles are equal.
29 / 246
Examples of Equivalence Relations [6]
Example (Rational numbers): On the set of ordered pairs â„¤ Ã— (â„¤ âˆ– {0}), define:
âŸ¨ğ‘, ğ‘âŸ© âˆ¼ âŸ¨ğ‘, ğ‘‘âŸ© iff ğ‘ â‹… ğ‘‘ = ğ‘ â‹… ğ‘
This relation is used to construct rational numbers â„š from integer pairs.
Verification:
â€¢ Reflexive: âŸ¨ğ‘, ğ‘âŸ© âˆ¼ âŸ¨ğ‘, ğ‘âŸ© since ğ‘ â‹… ğ‘ = ğ‘ â‹… ğ‘ âœ“
â€¢ Symmetric: If ğ‘ â‹… ğ‘‘ = ğ‘ â‹… ğ‘, then ğ‘ â‹… ğ‘ = ğ‘‘ â‹… ğ‘ âœ“
â€¢ Transitive: If ğ‘ â‹… ğ‘‘ = ğ‘ â‹… ğ‘ and ğ‘ â‹… ğ‘“ = ğ‘‘ â‹… ğ‘’, then ğ‘ â‹… ğ‘“ = ğ‘ â‹… ğ‘’ âœ“
Equivalence classes: Each equivalence class represents a rational number.
â€¢ [âŸ¨1, 2âŸ©]âˆ¼
= {âŸ¨1, 2âŸ©, âŸ¨2, 4âŸ©, âŸ¨3, 6âŸ©, âŸ¨âˆ’1,
âˆ’2âŸ©, â€¦} represents 1
2
â€¢ [âŸ¨3, 4âŸ©]âˆ¼
= {âŸ¨3, 4âŸ©, âŸ¨6, 8âŸ©, âŸ¨âˆ’3,
âˆ’4âŸ©, â€¦} represents 3
4
Mathematical significance: This construction shows how equivalence relations create new mathematical
objects (rationals) from simpler ones (integers).
30 / 246
Quotient Sets
Definition 18: The quotient set of ğ‘€ by the equivalence relation ğ‘… is the set of all equivalence classes:
ğ‘€/ğ‘… = {[ğ‘¥]ğ‘… | ğ‘¥ âˆˆ ğ‘€}
Example: Consider ğ‘€ = {0, 1, 2, 3, 4, 5} with the equivalence relation â€œcongruent modulo 3â€:
ğ‘¥ â‰¡ ğ‘¦ (mod 3) iff 3 | (ğ‘¥ âˆ’ ğ‘¦)
Equivalence classes:
â€¢ [0]â‰¡
= {0, 3} = {ğ‘¥ âˆˆ ğ‘€ | ğ‘¥ â‰¡ 0 (mod 3)}
â€¢ [1]â‰¡
= {1, 4} = {ğ‘¥ âˆˆ ğ‘€ | ğ‘¥ â‰¡ 1 (mod 3)}
â€¢ [2]â‰¡
= {2, 5} = {ğ‘¥ âˆˆ ğ‘€ | ğ‘¥ â‰¡ 2 (mod 3)}
Quotient set:
Note that [3]â‰¡
= [0]â‰¡
ğ‘€/â‰¡
= {{0, 3}, {1, 4}, {2, 5}}
= {0, 3}, so we donâ€™t get a new equivalence class, since ğ‘€/ğ‘… is a set.
31 / 246
Quotient Sets [2]
Example: Let ğ‘€ = {a, ab, abc, x, xy, z} with equivalence relation ğ‘… defined by:
ğ‘ 1 ğ‘… ğ‘ 2 iff |ğ‘ 1| = |ğ‘ 2|
where |ğ‘ | denotes the length of string ğ‘ .
Equivalence classes by length:
â€¢ [a]ğ‘… = {a, x, z} (strings of length 1)
â€¢ [ab]ğ‘… = {ab, xy} (strings of length 2)
â€¢ [abc]ğ‘… = {abc} (strings of length 3)
Quotient set:
ğ‘€/ğ‘… = {{a, x, z}, {ab, xy}, {abc}}
This partitions strings by their length, creating 3 equivalence classes.
32 / 246
Quotient Sets [3]
Example (Construction of rational numbers): Consider the set of ordered pairs ğ‘€ = â„¤ Ã— (â„¤ âˆ– {0}).
Define the equivalence relation âˆ¼ by:
âŸ¨ğ‘, ğ‘âŸ© âˆ¼ âŸ¨ğ‘, ğ‘‘âŸ© iff ğ‘ â‹… ğ‘‘ = ğ‘ â‹… ğ‘
Equivalence classes: Each represents a rational number in its â€œreduced formâ€.
Representative Equivalence Class Rational Number
âŸ¨1, 2âŸ© âŸ¨0, 1âŸ© âŸ¨3, 4âŸ© {âŸ¨1, 2âŸ©, âŸ¨2, 4âŸ©, âŸ¨3, 6âŸ©, âŸ¨âˆ’1,
âˆ’2âŸ©, âŸ¨âˆ’2,
âˆ’4âŸ©, â€¦} 1/2
{âŸ¨0, 1âŸ©, âŸ¨0, 2âŸ©, âŸ¨0,
âˆ’3âŸ©, âŸ¨0, 7âŸ©, â€¦} 0
{âŸ¨3, 4âŸ©, âŸ¨6, 8âŸ©, âŸ¨âˆ’3,
âˆ’4âŸ©, âŸ¨9, 12âŸ©, â€¦} 3/4
âŸ¨âˆ’5, 3âŸ© {âŸ¨âˆ’5, 3âŸ©, âŸ¨5,
âˆ’3âŸ©, âŸ¨âˆ’10, 6âŸ©, âŸ¨10,
âˆ’6âŸ©, â€¦} âˆ’5/3
Quotient set: All equivalence classes together form the set of rational numbers:
â„š â‰” (â„¤ Ã— (â„¤ âˆ– {0}))/âˆ¼
= {[âŸ¨ğ‘, ğ‘âŸ©]âˆ¼ | âŸ¨ğ‘, ğ‘âŸ© âˆˆ â„¤ Ã— (â„¤ âˆ– {0})}
33 / 246
Quotient Sets [4]
Interpretation: Each equivalence class [âŸ¨ğ‘, ğ‘âŸ©]âˆ¼ corresponds exactly to the rational number ğ‘
ğ‘.
â€¢ Different representations âŸ¨ğ‘, ğ‘âŸ© and âŸ¨ğ‘, ğ‘‘âŸ© belong to the same equivalence class iff they represent the
same fraction: ğ‘
ğ‘ =
ğ‘
ğ‘‘
â€¢ The condition ğ‘ â‹… ğ‘‘ = ğ‘ â‹… ğ‘ is the cross-multiplication test for fraction equality
Operations on the quotient set: We can define arithmetic operations on â„š by:
[âŸ¨ğ‘, ğ‘âŸ©]âˆ¼ + [âŸ¨ğ‘, ğ‘‘âŸ©]âˆ¼
[âŸ¨ğ‘, ğ‘âŸ©]âˆ¼
â‹… [âŸ¨ğ‘, ğ‘‘âŸ©]âˆ¼
â‰” [âŸ¨ğ‘ğ‘‘ + ğ‘ğ‘, ğ‘ğ‘‘âŸ©]âˆ¼
â‰” [âŸ¨ğ‘ğ‘, ğ‘ğ‘‘âŸ©]âˆ¼
These operations are well-defined because the result doesnâ€™t depend on the choice of representatives.
Mathematical significance:
â€¢ This construction shows that â„š is literally the quotient set â„¤ Ã— (â„¤ âˆ– {0})/âˆ¼
â€¢ It demonstrates how equivalence relations and quotient sets create new mathematical structures
â€¢ This is the rigorous foundation for rational number arithmetic taught in elementary school
34 / 246
Quotient Sets [5]
Example: Consider the set of all points in the plane ğ‘€ = â„2 with the equivalence relation:
âŸ¨ğ‘¥1, ğ‘¦1âŸ© âˆ¼ âŸ¨ğ‘¥2, ğ‘¦2âŸ© iff ğ‘¥1 + ğ‘¦1 = ğ‘¥2 + ğ‘¦2
This relation groups points that lie on the same line of the form ğ‘¥ + ğ‘¦ = ğ‘ for some constant ğ‘.
Equivalence classes:
â€¢ [âŸ¨0, 0âŸ©]âˆ¼
= {âŸ¨ğ‘¥, ğ‘¦âŸ© | ğ‘¥ + ğ‘¦ = 0} (the line ğ‘¥ + ğ‘¦ = 0)
â€¢ [âŸ¨1, 0âŸ©]âˆ¼
= {âŸ¨ğ‘¥, ğ‘¦âŸ© | ğ‘¥ + ğ‘¦ = 1} (the line ğ‘¥ + ğ‘¦ = 1)
â€¢ [âŸ¨0, 2âŸ©]âˆ¼
= {âŸ¨ğ‘¥, ğ‘¦âŸ© | ğ‘¥ + ğ‘¦ = 2} (the line ğ‘¥ + ğ‘¦ = 2)
Quotient set:
â„2/âˆ¼
= {ğ¿ğ‘ | ğ‘ âˆˆ â„}
where ğ¿ğ‘
= {âŸ¨ğ‘¥, ğ‘¦âŸ© | ğ‘¥ + ğ‘¦ = ğ‘} is the line with equation ğ‘¥ + ğ‘¦ = ğ‘.
Each equivalence class is an entire line, and the quotient set consists of all such parallel lines.
35 / 246
Quotient Sets [6]
Example: Let ğ‘€ = {apple, ant, banana, bee, cherry, cat} with equivalence relation:
ğ‘¤1 ğ‘… ğ‘¤2 iff first letter of ğ‘¤1 = first letter of ğ‘¤2
Equivalence classes:
â€¢ [apple]ğ‘… = {apple, ant} (words starting with â€˜aâ€™)
â€¢ [banana]ğ‘… = {banana, bee} (words starting with â€˜bâ€™)
â€¢ [cherry]ğ‘… = {cherry, cat} (words starting with â€˜câ€™)
Quotient set:
ğ‘€/ğ‘… = {{apple, ant}, {banana, bee}, {cherry, cat}}
This creates a dictionary-like grouping by first letter.
36 / 246
Quotient Sets [7]
Example (Trivial quotient sets):
Identity relation: If ğ‘… = ğ¼ğ‘€ (identity relation), then each element forms its own equivalence class:
ğ‘€/ğ¼ğ‘€
= {{ğ‘¥} | ğ‘¥ âˆˆ ğ‘€}
The quotient set has the same cardinality as the original set.
Universal relation: If ğ‘… = ğ‘€ Ã— ğ‘€ (universal relation), then all elements are equivalent:
ğ‘€/ğ‘€Ã—ğ‘€ = {ğ‘€}
The quotient set contains exactly one equivalence class â€” the entire set ğ‘€.
37 / 246
Set Partitions
Definition 19: A partition ğ’«ï¸€ of a set ğ‘€ is a family of non-empty, pairwise-disjoint subsets whose
union is ğ‘€:
â€¢ (Non-empty) âˆ€ğµ âˆˆ ğ’«ï¸€. (ğµ â‰  âˆ…)
â€¢ (Disjoint) âˆ€ğµ1, ğµ2 âˆˆ ğ’«ï¸€. (ğµ1 â‰  ğµ2) â†’ (ğµ1 âˆ© ğµ2 = âˆ…)
â€¢ (Cover) â‹ƒ
ğµ = ğ‘€
ğµâˆˆğ’«ï¸€
Elements of ğ’«ï¸€ are blocks (or cells).
Example: For ğ‘€ = {0, 1, 2, 3, 4, 5}: {{0, 2, 4}, {1, 3, 5}} and {{0, 5}, {1, 2, 3}, {4}} are partitions.
0
2
4
0
5
4
1
3
5
1
2
3
38 / 246
Partitions and Equivalence Relations
Theorem 1 (Equivalences â‡” Partitions): Each equivalence relation ğ‘… on ğ‘€ yields the partition
ğ’«ï¸€ ğ‘… = {[ğ‘¥]ğ‘… | ğ‘¥ âˆˆ ğ‘€}. Each partition ğ’«ï¸€ yields an equivalence ğ‘…ğ’«ï¸€ given by âŸ¨ğ‘¥, ğ‘¦âŸ© âˆˆ ğ‘…ğ’«ï¸€ iff ğ‘¥ and ğ‘¦ lie
in the same block. These constructions invert one another.
Proof (Sketch): Classes of an equivalence are non-empty, disjoint, and cover ğ‘€. Conversely, â€œsame blockâ€
relation is reflexive, symmetric, transitive. Composing the two constructions returns exactly the starting
equivalence relation or partition (they are mutually inverse up to equality of sets of ordered pairs). â–¡
39 / 246
Composition of Relations
Composition of Relations
Definition 20: The composition of two relations ğ‘… âŠ† ğ´ Ã— ğµ and ğ‘† âŠ† ğµ Ã— ğ¶ is defined as:
ğ‘… ; ğ‘† = ğ‘† âˆ˜ ğ‘… = {âŸ¨ğ‘, ğ‘âŸ© | âˆƒğ‘ âˆˆ ğµ. (ğ‘ ğ‘… ğ‘) âˆ§ (ğ‘ ğ‘† ğ‘)}
Example: Let ğ´ = {1, 2, 3}, ğµ = {ğ‘, ğ‘, ğ‘, ğ‘‘}, ğ¶ = {ğ‘¥, ğ‘¦} with relations:
â€¢ ğ‘… = {âŸ¨1, ğ‘âŸ©, âŸ¨1, ğ‘âŸ©, âŸ¨2, ğ‘âŸ©, âŸ¨3, ğ‘‘âŸ©} âŠ† ğ´ Ã— ğµ
â€¢ ğ‘† = {âŸ¨ğ‘, ğ‘¥âŸ©, âŸ¨ğ‘, ğ‘¦âŸ©, âŸ¨ğ‘, ğ‘¥âŸ©} âŠ† ğµ Ã— ğ¶
To find ğ‘… ; ğ‘†, we look for pairs âŸ¨ğ‘–, ğ‘§âŸ© where there exists ğ‘¤ such that âŸ¨ğ‘–, ğ‘¤âŸ© âˆˆ ğ‘… and âŸ¨ğ‘¤, ğ‘§âŸ© âˆˆ ğ‘†:
From 1: can reach ğ‘ and ğ‘ via ğ‘…
â€¢ ğ‘ connects to ğ‘¥ via ğ‘† â‡’ âŸ¨1, ğ‘¥âŸ© is in the composition
â€¢ ğ‘ connects to ğ‘¦ via ğ‘† â‡’ âŸ¨1, ğ‘¦âŸ© is in the composition
From 2: can reach ğ‘ via ğ‘…
â€¢ ğ‘ connects to ğ‘¥ via ğ‘† â‡’ âŸ¨2, ğ‘¥âŸ© is in the composition
From 3: can reach ğ‘‘ via ğ‘…
41 / 246
Composition of Relations [2]
â€¢ ğ‘‘ has no outgoing connections in ğ‘† â‡’ no pairs from 3 in the composition
Therefore: ğ‘… ; ğ‘† = {âŸ¨1, ğ‘¥âŸ©, âŸ¨1, ğ‘¦âŸ©, âŸ¨2, ğ‘¥âŸ©}
ğ‘
1
ğ‘
ğ‘¥
2
ğ‘
ğ‘¦
3
ğ‘‘
Edges legend:
â€¢ Solid: Relations ğ‘… and ğ‘†
â€¢ Dashed: Composition ğ‘… ; ğ‘†
â€¢ Red: Dead end (no outgoing path)
42 / 246
Examples of Composition
Example (Composition in a social network): Consider three sets:
â€¢ People = {Alice, Bob, Carol}
â€¢ Skills = {Python, Design, Management}
â€¢ Projects = {WebApp, Mobile, Analytics}
Define relations:
â€¢ HasSkill = {âŸ¨Alice, PythonâŸ©, âŸ¨Alice, DesignâŸ©, âŸ¨Bob, PythonâŸ©, âŸ¨Carol, ManagementâŸ©}
â€¢ RequiresSkill = {âŸ¨Python, WebAppâŸ©, âŸ¨Python, AnalyticsâŸ©, âŸ¨Design, WebAppâŸ©, âŸ¨Management, MobileâŸ©}
The composition HasSkill ; RequiresSkill gives us CanWorkOn:
â€¢ Alice can work on WebApp (via Python AND Design)
â€¢ Alice can work on Analytics (via Python)
â€¢ Bob can work on WebApp (via Python)
â€¢ Bob can work on Analytics (via Python)
â€¢ Carol can work on Mobile (via Management)
So: CanWorkOn =
{âŸ¨Alice, WebAppâŸ©, âŸ¨Alice, AnalyticsâŸ©, âŸ¨Bob, WebAppâŸ©, âŸ¨Bob, AnalyticsâŸ©, âŸ¨Carol, MobileâŸ©}
43 / 246
Examples of Composition [2]
Example (Matrix composition): Relations can be composed using Boolean matrix multiplication.
Given ğ‘… âŠ† {1, 2} Ã— {ğ‘, ğ‘} and ğ‘† âŠ† {ğ‘, ğ‘} Ã— {ğ‘¥, ğ‘¦}:
âŸ¦ğ‘…âŸ§ = [1
1
0
1] âŸ¦ğ‘†âŸ§ = [1
0
1
1]
The composition âŸ¦ğ‘… ; ğ‘†âŸ§ = âŸ¦ğ‘…âŸ§ âŠ™ âŸ¦ğ‘†âŸ§ using Boolean matrix multiplication:
âŸ¦ğ‘… ; ğ‘†âŸ§ = [(1 âˆ§ 1) âˆ¨ (0 âˆ§ 0)
(1 âˆ§ 1) âˆ¨ (1 âˆ§ 0)
(1 âˆ§ 1) âˆ¨ (0 âˆ§ 1)
(1 âˆ§ 1) âˆ¨ (1 âˆ§ 1)] = [1
1
This means ğ‘… ; ğ‘† = {âŸ¨1, ğ‘¥âŸ©, âŸ¨1, ğ‘¦âŸ©, âŸ¨2, ğ‘¥âŸ©, âŸ¨2, ğ‘¦âŸ©} (the universal relation).
1
1]
44 / 246
Powers of Relations
Definition 21: For a homogeneous relation ğ‘… âŠ† ğ‘€2, we define powers of ğ‘…:
â€¢ ğ‘…0 = ğ¼ğ‘€ (identity relation)
â€¢ ğ‘…1 = ğ‘…
â€¢ ğ‘…ğ‘›+1 = ğ‘…ğ‘› âˆ˜ ğ‘… for ğ‘› â‰¥ 1
Example: Let ğ‘€ = {1, 2, 3, 4} and ğ‘… = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨3, 4âŸ©} (successor relation).
â€¢ ğ‘…1 = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨3, 4âŸ©}
â€¢ ğ‘…2 = {âŸ¨1, 3âŸ©, âŸ¨2, 4âŸ©} (two steps)
â€¢ ğ‘…3 = {âŸ¨1, 4âŸ©} (three steps)
â€¢ ğ‘…4 = âˆ… (no four-step paths) ğ‘…2 ğ‘…2
1 2 3 4
ğ‘…3
45 / 246
Paths in Graphs
Example (Path composition in a graph): Consider a directed graph with vertices {ğ´, ğµ, ğ¶, ğ·} and
relation ğ‘… representing direct edges: ğ‘… = {âŸ¨ğ´, ğµâŸ©, âŸ¨ğµ, ğ¶âŸ©, âŸ¨ğµ, ğ·âŸ©, âŸ¨ğ¶, ğ·âŸ©}
Powers of ğ‘… represent paths of different lengths:
â€¢ ğ‘…1 = ğ‘… (direct connections)
â€¢ ğ‘…2 = ğ‘… âˆ˜ ğ‘… (2-step paths):
â€£ âŸ¨ğ´, ğ¶âŸ©: path ğ´ â†’ ğµ â†’ ğ¶
â€£ âŸ¨ğ´, ğ·âŸ©: path ğ´ â†’ ğµ â†’ ğ·
â€£ âŸ¨ğµ, ğ·âŸ©: path ğµ â†’ ğ¶ â†’ ğ·
â€£ So ğ‘…2 = {âŸ¨ğ´, ğ¶âŸ©, âŸ¨ğ´, ğ·âŸ©, âŸ¨ğµ, ğ·âŸ©}.
â€¢ ğ‘…3 = ğ‘…2 âˆ˜ ğ‘… (3-step paths):
â€£ âŸ¨ğ´, ğ·âŸ©: path ğ´ â†’ ğµ â†’ ğ¶ â†’ ğ·
â€£ No more 3-step paths!
â€£ So ğ‘…3 = {âŸ¨ğ´, ğ·âŸ©}.
â€¢ ğ‘…4 = âˆ… (no 4-step paths)
ğ´ ğµ
ğ·
ğ¶
46 / 246
Associativity of Composition
Theorem 2: Composition of relations is associative: (ğ‘… ; ğ‘†) ; ğ‘‡ = ğ‘… ; (ğ‘† ; ğ‘‡).
Proof: Let ğ‘… âŠ† ğ´ Ã— ğµ, ğ‘† âŠ† ğµ Ã— ğ¶, and ğ‘‡ âŠ† ğ¶ Ã— ğ· be three relations.
(âŠ†): Let âŸ¨ğ‘, ğ‘‘âŸ© âˆˆ (ğ‘… ; ğ‘†) ; ğ‘‡.
â€¢ By definition of composition: âˆƒğ‘ âˆˆ ğ¶. (âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘… ; ğ‘†) âˆ§ (âŸ¨ğ‘, ğ‘‘âŸ© âˆˆ ğ‘‡).
â€¢ Since âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘… ; ğ‘†, we have: âˆƒğ‘ âˆˆ ğµ. (âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘…) âˆ§ (âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘†).
â€¢ From âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘† and âŸ¨ğ‘, ğ‘‘âŸ© âˆˆ ğ‘‡, we have: âŸ¨ğ‘, ğ‘‘âŸ© âˆˆ ğ‘† ; ğ‘‡.
â€¢ From âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘… and âŸ¨ğ‘, ğ‘‘âŸ© âˆˆ ğ‘† ; ğ‘‡, we have: âŸ¨ğ‘, ğ‘‘âŸ© âˆˆ ğ‘… ; (ğ‘† ; ğ‘‡).
(âŠ‡): Let âŸ¨ğ‘, ğ‘‘âŸ© âˆˆ ğ‘… ; (ğ‘† ; ğ‘‡).
â€¢ By definition of composition: âˆƒğ‘ âˆˆ ğµ. (âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘…) âˆ§ (âŸ¨ğ‘, ğ‘‘âŸ© âˆˆ ğ‘† ; ğ‘‡).
â€¢ Since âŸ¨ğ‘, ğ‘‘âŸ© âˆˆ ğ‘† ; ğ‘‡, we have: âˆƒğ‘ âˆˆ ğ¶. (âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘†) âˆ§ (âŸ¨ğ‘, ğ‘‘âŸ© âˆˆ ğ‘‡).
â€¢ From âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘… and âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘†, we have: âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘… ; ğ‘†.
â€¢ From âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘… ; ğ‘† and âŸ¨ğ‘, ğ‘‘âŸ© âˆˆ ğ‘‡, we have: âŸ¨ğ‘, ğ‘‘âŸ© âˆˆ (ğ‘… ; ğ‘†) ; ğ‘‡.
Therefore, (ğ‘… ; ğ‘†) ; ğ‘‡ = ğ‘… ; (ğ‘† ; ğ‘‡). â–¡
47 / 246
Closures of Relations
What is a Closure?
Sometimes we have a relation that almost has a property we want, but not quite.
Example (Motivation):
â€¢ You have relation ğ‘… = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©} on {1, 2, 3}
â€¢ Itâ€™s not reflexive (missing self-loops)
â€¢ Itâ€™s not symmetric (arrows only go one way)
â€¢ Itâ€™s not transitive (missing âŸ¨1, 3âŸ©)
How do we â€œfixâ€ ğ‘… to get these properties?
Definition 22: The closure of relation ğ‘… with respect to property ğ‘ƒ is the smallest relation containing
ğ‘… that has property ğ‘ƒ.
Think of it as: â€œminimally extend ğ‘… to satisfy ğ‘ƒâ€.
Key insight: Closures add the minimum pairs needed â€” no more, no less.
49 / 246
Reflexive Closure
Definition 23: The reflexive closure of ğ‘… âŠ† ğ‘€2 is:
ğ‘Ÿ(ğ‘…) = ğ‘… âˆª ğ¼ğ‘€ = ğ‘… âˆª {âŸ¨ğ‘¥, ğ‘¥âŸ© | ğ‘¥ âˆˆ ğ‘€}
Add all missing self-loops: âŸ¨ğ‘¥, ğ‘¥âŸ© for every ğ‘¥ âˆˆ ğ‘€ that doesnâ€™t already relate to itself.
Example: Let ğ‘€ = {1, 2, 3} and ğ‘… = {âŸ¨1, 2âŸ©, âŸ¨2, 2âŸ©, âŸ¨2, 3âŸ©}.
â€¢ Element 2 already has âŸ¨2, 2âŸ©
â€¢ Elements 1 and 3 are missing self-loops
â€¢ Add: âŸ¨1, 1âŸ© and âŸ¨3, 3âŸ©
Result: ğ‘Ÿ(ğ‘…) = {âŸ¨1, 1âŸ©, âŸ¨1, 2âŸ©, âŸ¨2, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨3, 3âŸ©}
Graph view: Add self-loop to every vertex.
Matrix view: Set all diagonal entries to 1.
50 / 246
Symmetric Closure
Definition 24: The symmetric closure of ğ‘… âŠ† ğ‘€2 is:
ğ‘ (ğ‘…) = ğ‘… âˆª ğ‘…âˆ’1 = ğ‘… âˆª {âŸ¨ğ‘, ğ‘âŸ© | âŸ¨ğ‘, ğ‘âŸ© âˆˆ ğ‘…}
For every pair in ğ‘…, add its reverse (if not already present).
Example: Let ğ‘€ = {1, 2, 3} and ğ‘… = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨1, 3âŸ©}.
For each pair, add the reverse:
â€¢ âŸ¨1, 2âŸ© âˆˆ ğ‘… â‡’ add âŸ¨2, 1âŸ©
â€¢ âŸ¨2, 3âŸ© âˆˆ ğ‘… â‡’ add âŸ¨3, 2âŸ©
â€¢ âŸ¨1, 3âŸ© âˆˆ ğ‘… â‡’ add âŸ¨3, 1âŸ©
Result: ğ‘ (ğ‘…) = {âŸ¨1, 2âŸ©, âŸ¨2, 1âŸ©, âŸ¨1, 3âŸ©, âŸ¨3, 1âŸ©, âŸ¨2, 3âŸ©, âŸ¨3, 2âŸ©}
Graph view: Every directed edge becomes bidirectional.
Matrix view: Make matrix symmetric.
51 / 246
Transitive Closure
Definition 25: The transitive closure ğ‘¡(ğ‘…) of ğ‘… âŠ† ğ‘€2 is the smallest transitive relation containing ğ‘….
Theorem 3: The transitive closure can be computed as:
ğ‘¡(ğ‘…) = â‹ƒâˆ
ğ‘›=1
ğ‘…ğ‘› = ğ‘… âˆª ğ‘…2 âˆª ğ‘…3 âˆª â€¦
where ğ‘…ğ‘› represents all ğ‘›-step paths (relation composition power: ğ‘…ğ‘›+1 = ğ‘…ğ‘› âˆ˜ ğ‘…).
For finite ğ‘€ with |ğ‘€| = ğ‘˜, we have: ğ‘¡(ğ‘…) = ğ‘… âˆª ğ‘…2 âˆª â€¦ âˆª ğ‘…ğ‘˜
.
Proof: Any path longer than |ğ‘€| must repeat vertices, so paths up to length |ğ‘€| suffice. â–¡
Intuition: Add shortcuts for all multi-step paths. If you can reach ğ‘ from ğ‘ through intermediate steps
(ğ‘ â†’ ğ‘ â†’ ğ‘), make ğ‘ directly relate to ğ‘: add ğ‘ â†’ ğ‘.
52 / 246
Computing Transitive Closure: Example
Example: Let ğ‘€ = {1, 2, 3} and ğ‘… = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©} (a chain: 1 â†’ 2 â†’ 3).
Step Description New pairs added Result
Step 1: Direct connections
(ğ‘…1 = ğ‘…)
Step 2: Two-step paths
(ğ‘…2 = ğ‘… âˆ˜ ğ‘…)
Step 3: Three-step paths
(ğ‘…3 = ğ‘…2 âˆ˜ ğ‘…)
Final Result: Transitive closure âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ© âŸ¨1, 3âŸ© from path 1 â†’ 2 â†’ 3 None (no three-step paths) âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨1, 3âŸ© ğ‘…1 = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©}
ğ‘…2 = {âŸ¨1, 3âŸ©}
ğ‘…3 = âˆ…
ğ‘¡(ğ‘…) = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨1, 3âŸ©}
Result: The â€œshortcutâ€ âŸ¨1, 3âŸ© was added to connect the chain endpoints.
53 / 246
Combining Closures
Closures can be combined to achieve multiple properties at once.
Definition 26: Common combinations:
â€¢ Reflexive-symmetric: ğ‘ ğ‘Ÿ(ğ‘…) = ğ‘ (ğ‘Ÿ(ğ‘…)) â€” add self-loops and reverse arrows
â€¢ Reflexive-transitive: ğ‘¡ğ‘Ÿ(ğ‘…) = ğ‘¡(ğ‘Ÿ(ğ‘…)) â€” add self-loops and shortcuts
â€¢ Equivalence closure: ğ‘¡ğ‘ ğ‘Ÿ(ğ‘…) = ğ‘¡(ğ‘ (ğ‘Ÿ(ğ‘…))) â€” make reflexive, symmetric, and transitive
Theorem 4 (Commutativity):
â€¢ Reflexive and symmetric closures commute: ğ‘ ğ‘Ÿ(ğ‘…) = ğ‘Ÿğ‘ (ğ‘…)
â€¢ Reflexive and transitive closures commute: ğ‘¡ğ‘Ÿ(ğ‘…) = ğ‘Ÿğ‘¡(ğ‘…)
â€¢ Equivalence (reflexive-symmetric-transitive) closure is independent of the order of ğ‘Ÿ and ğ‘ , if ğ‘¡ is
applied last: ğ‘¡ğ‘ ğ‘Ÿ(ğ‘…) = ğ‘¡ğ‘Ÿğ‘ (ğ‘…), which is equavalent to ğ‘¡(ğ‘Ÿğ‘ (ğ‘…)) = ğ‘¡(ğ‘ ğ‘Ÿ(ğ‘…)).
Note: Order matters for some combinations! Generally safe: reflexive and symmetric commute with most
operations, but transitive closure should be computed last when combining all three.
54 / 246
Example: Reflexive-Symmetric Closure
Example: Let ğ‘€ = {1, 2, 3} and ğ‘… = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©}.
We want both reflexivity and symmetry. Order doesnâ€™t matter!
Method 1: Reflexive first, then symmetric
ğ‘Ÿ(ğ‘…) = {âŸ¨1, 1âŸ©, âŸ¨1, 2âŸ©, âŸ¨2, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨3, 3âŸ©}
ğ‘ ğ‘Ÿ(ğ‘…) = {âŸ¨1, 1âŸ©, âŸ¨1, 2âŸ©, âŸ¨2, 1âŸ©, âŸ¨2, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨3, 2âŸ©, âŸ¨3, 3âŸ©}
Method 2: Symmetric first, then reflexive
ğ‘ (ğ‘…) = {âŸ¨1, 2âŸ©, âŸ¨2, 1âŸ©, âŸ¨2, 3âŸ©, âŸ¨3, 2âŸ©}
ğ‘Ÿğ‘ (ğ‘…) = {âŸ¨1, 1âŸ©, âŸ¨1, 2âŸ©, âŸ¨2, 1âŸ©, âŸ¨2, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨3, 2âŸ©, âŸ¨3, 3âŸ©}
Both methods give the same result: ğ‘Ÿğ‘ (ğ‘…) = ğ‘ ğ‘Ÿ(ğ‘…) âœ“
55 / 246
Example: Reflexive-Transitive Closure
The reflexive-transitive closure is particularly important and has a special notation.
Example: Let ğ‘€ = {ğ‘, ğ‘, ğ‘} and ğ‘… = {âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©} (a chain).
Step 1: Compute transitive closure
ğ‘¡(ğ‘…) = ğ‘… âˆª ğ‘…2 = {âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©}
Step 2: Add reflexivity
ğ‘Ÿğ‘¡(ğ‘…) = ğ‘¡(ğ‘…) âˆª ğ¼ğ‘€ = {âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©}
Note: The reflexive-transitive closure is often denoted ğ‘…âˆ— (Kleene star).
It represents: â€œreachable in zero or more stepsâ€ â€” fundamental in automata theory and formal languages.
56 / 246
Example: Equivalence Closure
The equivalence closure makes a relation reflexive, symmetric, and transitive.
Example: Let ğ‘€ = {1, 2, 3, 4} and ğ‘… = {âŸ¨1, 2âŸ©, âŸ¨3, 4âŸ©} (two separate connections).
Step Description New pairs Result
Step 1: Step 2: Reflexive closure Symmetric closure âŸ¨1, 1âŸ©, âŸ¨2, 2âŸ©, âŸ¨3, 3âŸ©, âŸ¨4, 4âŸ© âŸ¨2, 1âŸ©, âŸ¨4, 3âŸ© ğ‘Ÿ(ğ‘…) = {âŸ¨1, 1âŸ©, âŸ¨1, 2âŸ©, âŸ¨2, 2âŸ©,
âŸ¨3, 3âŸ©, âŸ¨3, 4âŸ©, âŸ¨4, 4âŸ©}
ğ‘ ğ‘Ÿ(ğ‘…) = {âŸ¨1, 1âŸ©, âŸ¨1, 2âŸ©, âŸ¨2, 1âŸ©, âŸ¨2, 2âŸ©,
âŸ¨3, 3âŸ©, âŸ¨3, 4âŸ©, âŸ¨4, 3âŸ©, âŸ¨4, 4âŸ©}
Step 3: Transitive closure None (no new pairs needed) ğ‘¡ğ‘ ğ‘Ÿ(ğ‘…) = ğ‘ ğ‘Ÿ(ğ‘…)
Result: The equivalence closure creates two equivalence classes: {1, 2} and {3, 4}.
57 / 246
Another Example: Equivalence Closure
Example: Let ğ‘€ = {ğ‘, ğ‘, ğ‘, ğ‘‘, ğ‘’} and ğ‘… = {âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘‘, ğ‘’âŸ©} (chain ğ‘ â†’ ğ‘ â†’ ğ‘ and pair ğ‘‘ â†’ ğ‘’).
Step 1: Add reflexivity â€” all self-loops
ğ‘Ÿ(ğ‘…) = ğ‘… âˆª {âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘‘, ğ‘‘âŸ©, âŸ¨ğ‘’, ğ‘’âŸ©}
Step 2: Add symmetry â€” reverse all arrows
ğ‘ ğ‘Ÿ(ğ‘…) = ğ‘Ÿ(ğ‘…) âˆª {âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘’, ğ‘‘âŸ©}
Step 3: Add transitivity â€” connect all chains
â€¢ Chain ğ‘ â†” ğ‘ â†” ğ‘ needs shortcuts: âŸ¨ğ‘, ğ‘âŸ© and âŸ¨ğ‘, ğ‘âŸ©
â€¢ Pair ğ‘‘ â†” ğ‘’ is already bi-connected
ğ‘¡ğ‘ ğ‘Ÿ(ğ‘…) = ğ‘ ğ‘Ÿ(ğ‘…) âˆª {âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©}
Result: Two equivalence classes emerge: {ğ‘, ğ‘, ğ‘} (connected chain) and {ğ‘‘, ğ‘’} (connected pair).
58 / 246
Warshallâ€™s Algorithm
An efficient algorithm to compute transitive closure using dynamic programming.
Definition 27: Warshallâ€™s algorithm computes ğ‘¡(ğ‘…) in ğ‘‚(ğ‘›3) time.
Idea: Systematically check if paths exist through each vertex as an intermediate.
M = relmat(R) # Start with relation matrix
for k = 1 to n: # Try each vertex k as intermediate
for i = 1 to n:
for j = 1 to n:
# If path iâ†’k and kâ†’j exist, add iâ†’j
M[i,j] = M[i,j] OR (M[i,k] AND M[k,j])
Key insight: Consider each vertex in turn as a â€œstepping stoneâ€ to create shortcuts.
59 / 246
Warshallâ€™s Algorithm: Step-by-Step Example
Example: Graph: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 1 (a cycle)
Initial matrix:
ğ‘€(0) =
[
0
0
0
1
1
0
0
0
0
1
0
0
0
0
0]
1
ğ‘˜ = 1: Paths through vertex 1 as intermediate
ğ‘€(1) =
[
0
0
0
1
1
0
0
1
0
1
0
0
0
0
0]
1
New: 4 â†’ 1 â†’ 2, so add âŸ¨4, 2âŸ©
60 / 246
Warshallâ€™s Algorithm: Step-by-Step Example [2]
ğ‘˜ = 2: Paths through vertex 2
ğ‘€(2) =
[
0
0
0
1
1
0
0
1
1
1
0
1
0
0
0]
1
New: 1 â†’ 2 â†’ 3 and 4 â†’ 2 â†’ 3
ğ‘˜ = 3: Paths through vertex 3
ğ‘€(3) =
[
0
0
0
1
1
0
0
1
1
1
0
1
1
1
1]
1
New: paths to 4 via 3
61 / 246
Warshallâ€™s Algorithm: Step-by-Step Example [3]
ğ‘˜ = 4: Paths through vertex 4 (closes cycle!)
ğ‘€(4) =
[
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1]
1
Cycle means everything becomes reachable!
62 / 246
Applications of Transitive Closure
Example (Social network influence): In a â€œfollowsâ€ network: ğ‘… = {âŸ¨ğ´, ğµâŸ©, âŸ¨ğµ, ğ¶âŸ©, âŸ¨ğ¶, ğ·âŸ©, âŸ¨ğ´, ğ¸âŸ©}
Transitive closure ğ‘¡(ğ‘…) reveals indirect influence:
â€¢ ğ´ can be influenced by ğ¶ (through ğµ)
â€¢ ğ´ can be influenced by ğ· (through ğµ, then ğ¶)
Applications:
â€¢ Information propagation analysis
â€¢ Recommendation systems
â€¢ Influence maximization
Example (Software dependencies): Module ğ´ depends on ğµ if it imports/uses ğµ.
Transitive closure reveals:
â€¢ All transitive dependencies (what ğ´ ultimately needs)
â€¢ Build order (via topological sort)
â€¢ Circular dependencies (cycles in closure)
63 / 246
Mathematical Properties of Closures
Closures satisfy important mathematical properties.
Theorem 5: For any relation ğ‘… âŠ† ğ‘€2:
1. Idempotency: Closure of closure = closure
ğ‘Ÿ(ğ‘Ÿ(ğ‘…)) = ğ‘Ÿ(ğ‘…), ğ‘ (ğ‘ (ğ‘…)) = ğ‘ (ğ‘…), ğ‘¡(ğ‘¡(ğ‘…)) = ğ‘¡(ğ‘…)
2. Monotonicity: Larger relation â‡’ larger closure
ğ‘…1 âŠ† ğ‘…2 â†’ ğ‘Ÿ(ğ‘…1) âŠ† ğ‘Ÿ(ğ‘…2)
3. Extensivity: Closure contains original
ğ‘… âŠ† ğ‘Ÿ(ğ‘…), ğ‘… âŠ† ğ‘ (ğ‘…), ğ‘… âŠ† ğ‘¡(ğ‘…)
4. Distributivity: Closure of union = union of closures (for ğ‘Ÿ and ğ‘ )
ğ‘Ÿ(ğ‘…1 âˆª ğ‘…2) = ğ‘Ÿ(ğ‘…1) âˆª ğ‘Ÿ(ğ‘…2)
64 / 246
Special Cases of Closures
Example (Empty relation): Let ğ‘€ = {ğ‘, ğ‘, ğ‘} and ğ‘… = âˆ… (no pairs at all).
â€¢ ğ‘Ÿ(âˆ…) = ğ¼ğ‘€ = {âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©, âŸ¨ğ‘, ğ‘âŸ©} (add all self-loops)
â€¢ ğ‘ (âˆ…) = âˆ… (no pairs to reverse)
â€¢ ğ‘¡(âˆ…) = âˆ… (no paths to connect)
Note: Reflexive closure adds structure, but symmetric/transitive closures have no pairs to work with.
Example (Universal relation): Let ğ‘€ = {1, 2} and ğ‘… = ğ‘€ Ã— ğ‘€ (all 4 pairs).
â€¢ ğ‘Ÿ(ğ‘…) = ğ‘… (already has all self-loops)
â€¢ ğ‘ (ğ‘…) = ğ‘… (already symmetric)
â€¢ ğ‘¡(ğ‘…) = ğ‘… (already transitive)
Note: Universal relation already has all properties â€” closures donâ€™t add anything!
65 / 246
Non-Distributivity of Transitive Closure
Example: Let ğ‘…1 = {âŸ¨1, 2âŸ©} and ğ‘…2 = {âŸ¨2, 3âŸ©} on ğ‘€ = {1, 2, 3}.
Computing ğ‘¡(ğ‘…) separately:
Computing ğ‘¡(ğ‘…) on union:
â€¢ ğ‘¡(ğ‘…1) = {âŸ¨1, 2âŸ©} (no paths to close)
â€¢ ğ‘…1 âˆª ğ‘…2 = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©} (a chain!)
â€¢ ğ‘¡(ğ‘…2) = {âŸ¨2, 3âŸ©} (no paths to close)
â€¢ ğ‘¡(ğ‘…1 âˆª ğ‘…2) = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©, âŸ¨1, 3âŸ©} (adds shortcut âŸ¨1, 3âŸ©)
â€¢ ğ‘¡(ğ‘…1) âˆª ğ‘¡(ğ‘…2) = {âŸ¨1, 2âŸ©, âŸ¨2, 3âŸ©}
Result: ğ‘¡(ğ‘…1 âˆª ğ‘…2) âŠƒ ğ‘¡(ğ‘…1) âˆª ğ‘¡(ğ‘…2)
Key insight: Transitive closure does not distribute over union!
ğ‘¡(ğ‘…1 âˆª ğ‘…2) â‰  ğ‘¡(ğ‘…1) âˆª ğ‘¡(ğ‘…2)
Note: Reflexive and symmetric closures do distribute over union:
ğ‘Ÿ(ğ‘…1 âˆª ğ‘…2) = ğ‘Ÿ(ğ‘…1) âˆª ğ‘Ÿ(ğ‘…2) ğ‘ (ğ‘…1 âˆª ğ‘…2) = ğ‘ (ğ‘…1) âˆª ğ‘ (ğ‘…2)
66 / 246
Transitive Closure in Dependency Analysis
Example: Consider a directed acyclic graph (DAG) where ğ‘… represents â€œdepends onâ€ relationships:
ğ‘… = {âŸ¨ğ´, ğµâŸ©, âŸ¨ğµ, ğ¶âŸ©, âŸ¨ğ´, ğ·âŸ©, âŸ¨ğ·, ğ¶âŸ©}
C
Component ğ´ depends on ğµ and ğ·, which both depend on ğ¶.
B D
The transitive closure reveals all indirect dependencies:
ğ‘¡(ğ‘…) = ğ‘… âˆª {âŸ¨ğ´, ğ¶âŸ©}
A
Component ğ´ transitively depends on ğ¶ through two paths: ğ´ â†’ ğµ â†’ ğ¶ and ğ´ â†’ ğ· â†’ ğ¶.
Application: Build systems use transitive closure to determine the complete dependency tree and
optimal compilation order (possibly parallel).
67 / 246
Applications of Relation Closures
Example (Graph Reachability): In directed graphs, transitive closure determines reachability:
â€¢ Social networks: Finding mutual connections and influence propagation
â€¢ Transportation: Computing all possible routes between cities
â€¢ Citation networks: Tracking intellectual dependencies in research
â€¢ Web crawling: Discovering linked pages and site connectivity
Example (Program Analysis): Closure operations enable sophisticated program optimization:
â€¢ Data flow analysis: Transitive closure computes variable dependencies
â€¢ Call graph construction: Finding all possible function invocations
â€¢ Alias analysis: Determining which pointers may reference the same memory
â€¢ Taint analysis: Tracking information flow and potential vulnerabilities
Example (Database Systems): Relational databases extensively use closure computations:
â€¢ Recursive queries: Computing organizational hierarchies and bill-of-materials
â€¢ Join optimization: Finding efficient query execution plans
â€¢ Integrity constraints: Ensuring referential consistency across tables
â€¢ Data lineage: Tracking data provenance and transformation chains
68 / 246
Complexity of Closure Computations
Theorem 6: For a relation ğ‘… on a set with ğ‘› elements:
â€¢ Reflexive closure: ğ‘‚(ğ‘›) â€” simply add ğ‘› self-loops
â€¢ Symmetric closure: ğ‘‚(|ğ‘…|) â€” reverse each of the |ğ‘…| pairs
â€¢ Transitive closure: ğ‘‚(ğ‘›3) â€” Warshallâ€™s algorithm
Warning: The ğ‘‚(ğ‘›3) transitive closure bottleneck drives many algorithmic design decisions in
databases, compilers, and network analysis.
Note: Faster algorithms exist for specific graph types (e.g., ğ‘‚(ğ‘› + ğ‘š) for DAGs using topological sort).
69 / 246
Functions
â€œA function is a machine which converts a certain class of inputs
into a certain class of outputs.â€
â€” Norbert Wiener
Leonhard Euler Augustin-Louis
Cauchy
Karl
Weierstrass
Joseph-Louis
Lagrange
George PÃ³lya Norbert
Wiener
Definition of a Function
Definition 28: A function ğ‘“ from a set ğ´ to a set ğµ, denoted ğ‘“ : ğ´ â†’ ğµ, is a special kind of relation
ğ‘“ âŠ† ğ´ Ã— ğµ where every element of ğ´ is paired with exactly one element of ğµ.
This â€œexactly oneâ€ requirement breaks down into two conditions:
1. Functional property (right-unique or well-defined): Each input has at most one output. No input can
map to multiple different outputs.
âˆ€ğ‘ âˆˆ ğ´. âˆ€ğ‘1, ğ‘2 âˆˆ ğµ. (ğ‘“(ğ‘) = ğ‘1) âˆ§ (ğ‘“(ğ‘) = ğ‘2) â†’ (ğ‘1 = ğ‘2)
2. Total property (left-total or defined everywhere): Each input has at least one output. Every element in
the domain must map to something.
âˆ€ğ‘ âˆˆ ğ´. âˆƒğ‘ âˆˆ ğµ. ğ‘“(ğ‘) = ğ‘
71 / 246
Definition of a Function [2]
Definition 29: A relation that satisfies only the functional property (but not necessarily total) is called
a partial function, denoted ğ‘“ : ğ´ â†ªï¸ ğµ. It may be undefined for some inputs.
Definition 30: A relation that satisfies both properties is called a total function, denoted ğ‘“ : ğ´ â†’ ğµ.
It is defined for every input in its domain.
Note: In most contexts, when we say â€œfunctionâ€ we mean total function. Partial functions are explicitly
noted when needed, especially in computability theory and programming language semantics.
72 / 246
Examples of Functions
Example (Partial functions):
â€¢ Division: ğ‘“ : â„ Ã— â„ â†ªï¸ â„ defined by ğ‘“(ğ‘¥, ğ‘¦) =
ğ‘¥
ğ‘¦ is partial because ğ‘“(ğ‘¥, 0) is undefined.
â€¢ Square root on integers: ğ‘” : â„¤ â†ªï¸ â„ defined by ğ‘”(ğ‘›) = âˆšğ‘› is partial because negative integers have no
real square root.
â€¢ Array access: arr : â„• â†ªï¸ ğ‘‡ where arr(ğ‘–) returns the element at index ğ‘–, but is undefined for out-of-
bounds indices.
â€¢ Head of list: head : List[ğ‘‡] â†ªï¸ ğ‘‡ returns the first element, but is undefined for empty lists.
Example (Total functions):
â€¢ Absolute value: | â‹… | : â„ â†’ â„ is total â€” defined for all real numbers.
â€¢ Successor: ğ‘† : â„• â†’ â„• defined by ğ‘†(ğ‘›) = ğ‘› + 1 is total â€” defined for all natural numbers.
â€¢ Constant function: ğ‘“ : ğ´ â†’ ğµ defined by ğ‘“(ğ‘¥) = ğ‘0 for some fixed ğ‘0 âˆˆ ğµ is always total.
73 / 246
Domain, Codomain, Range
Definition 31: For a function ğ‘“ : ğ´ â†’ ğµ:
â€¢ The set ğ´ is called the domain of ğ‘“, denoted Dom(ğ‘“).
â€¢ The set ğµ is called the codomain of ğ‘“, denoted Cod(ğ‘“).
â€¢ The range (or image) of ğ‘“ is the set of all values that ğ‘“ actually takes:
Range(ğ‘“) = {ğ‘ âˆˆ ğµ | âˆƒğ‘ âˆˆ ğ´. ğ‘“(ğ‘) = ğ‘} = {ğ‘“(ğ‘) | ğ‘ âˆˆ ğ´}
Note: Range(ğ‘“) âŠ† Cod(ğ‘“)
Example: Let ğ´ = {1, 2, 3} and ğµ = {ğ‘¥, ğ‘¦, ğ‘§}, and define ğ‘“ = {âŸ¨1, ğ‘¥âŸ©, âŸ¨2, ğ‘¦âŸ©, âŸ¨3, ğ‘¥âŸ©}.
â€¢ ğ‘“ : ğ´ â†’ ğµ is a function from ğ´ to ğµ
â€¢ Dom(ğ‘“) = ğ´ = {1, 2, 3} (â€œfromâ€)
â€¢ Cod(ğ‘“) = ğµ = {ğ‘¥, ğ‘¦, ğ‘§} (â€œtoâ€)
â€¢ Range(ğ‘“) = {ğ‘¥, ğ‘¦} âŠ‚ ğµ (note that ğ‘§ is not in the range)
â€¢ We have ğ‘“(1) = ğ‘¥, ğ‘“(2) = ğ‘¦, ğ‘“(3) = ğ‘¥
1
2
3
ğ‘¥
ğ‘¦
ğ‘§
74 / 246
Examples of Domain, Codomain, Range
Example: Consider the squaring function ğ‘” : â„¤ â†’ â„¤ defined by ğ‘”(ğ‘›) = ğ‘›2
.
â€¢ Dom(ğ‘”) = Cod(ğ‘”) = â„¤ (all integers)
â€¢ Range(ğ‘”) = {0, 1, 4, 9, 16, â€¦} = {ğ‘›2 | ğ‘› âˆˆ â„•} (non-negative perfect squares)
Note that the range of ğ‘” is a proper subset of the codomain: Range(ğ‘”) âŠ‚ Cod(ğ‘”), since âˆ’1 âˆ‰ Range(ğ‘”).
Example: The absolute value function ğ‘“ : â„ â†’ â„ defined by ğ‘“(ğ‘¥) = |ğ‘¥|:
â€¢ Dom(ğ‘“) = Cod(ğ‘“) = â„ (all real numbers)
â€¢ Range(ğ‘“) = [0, âˆ) = {ğ‘¦ âˆˆ â„ | ğ‘¦ â‰¥ 0} (non-negative reals)
Example: The exponential function exp : â„ â†’ (0, âˆ) defined by exp(ğ‘¥) = ğ‘’ğ‘¥:
â€¢ Dom(exp) = â„ (all real numbers)
â€¢ Cod(exp) = (0, âˆ) (positive real numbers)
â€¢ Range(exp) = (0, âˆ) (same as codomain â€” this function is surjective!)
Note the careful choice of codomain: if we used exp : â„ â†’ â„, the range would still be (0, âˆ), making it
not surjective.
75 / 246
Image and Preimage of Sets
Definition 32: Let ğ‘“ : ğ´ â†’ ğµ be a function and let ğ‘† âŠ† ğ´. The image of ğ‘† under ğ‘“ is the set:
ğ‘“(ğ‘†) = {ğ‘“(ğ‘ ) | ğ‘  âˆˆ ğ‘†}
Note that ğ‘“(ğ‘†) âŠ† ğµ. The range of ğ‘“ is ğ‘“(ğ´).
Definition 33: Let ğ‘“ : ğ´ â†’ ğµ be a function and let ğ‘‡ âŠ† ğµ. The preimage of ğ‘‡ under ğ‘“ (or inverse
image of ğ‘‡) is the set of all elements in the domain that map into ğ‘‡:
ğ‘“âˆ’1(ğ‘‡) = {ğ‘ âˆˆ ğ´ | ğ‘“(ğ‘) âˆˆ ğ‘‡}
Note: The notation ğ‘“âˆ’1(ğ‘†) is used even if the inverse function ğ‘“âˆ’1 does not exist (i.e., if ğ‘“ is not bijective).
It always refers to the set of domain elements that map into ğ‘†.
76 / 246
Examples of Image and Preimage
Example: Let ğ‘“ : â„¤ â†’ â„¤ be ğ‘“(ğ‘¥) = ğ‘¥2
.
â€¢ Let ğ‘† = {âˆ’2,
âˆ’1, 0, 1, 2}.
â€£ Then ğ‘“(ğ‘†) = {ğ‘“(âˆ’2), ğ‘“(âˆ’1), ğ‘“(0), ğ‘“(1), ğ‘“(2)} = {4, 1, 0, 1, 4} = {0, 1, 4}.
â€¢ Let ğ‘‡1 = {1, 9}.
â€£ The preimage is ğ‘“âˆ’1(ğ‘‡1) = {ğ‘¥ âˆˆ â„¤ | ğ‘¥2 âˆˆ {1, 9}} = {âˆ’3,
âˆ’1, 1, 3}.
â€¢ Let ğ‘‡2 = {2, 3}.
â€£ The preimage is ğ‘“âˆ’1(ğ‘‡2) = {ğ‘¥ âˆˆ â„¤ | ğ‘¥2 âˆˆ {2, 3}} = âˆ….
77 / 246
Injective Functions
Definition 34: A function ğ‘“ : ğ´ â†’ ğµ is injective (left-unique or one-to-one3) if distinct elements in the
domain map to distinct elements in the codomain. Formally:
âˆ€ğ‘1, ğ‘2 âˆˆ ğ´. (ğ‘“(ğ‘1) = ğ‘“(ğ‘2)) â†’ (ğ‘1 = ğ‘2)
Equivalent formulation:
âˆ€ğ‘1, ğ‘2 âˆˆ ğ´. (ğ‘1 â‰  ğ‘2) â†’ (ğ‘“(ğ‘1) â‰  ğ‘“(ğ‘2))
1
ğ‘“
ğ‘“
ğ‘¥
2
ğ‘¦
3Do not confuse â€œone-to-oneâ€ with â€œone-to-one correspondenceâ€, which refers to a bijection â€” another concept!
78 / 246
Examples of Injective Functions
Key insight: An injective function never â€œcollapsesâ€ different inputs to the same output.
Each output has at most one pre-image.
Example: ğ‘“ : â„• â†’ â„• defined by ğ‘“(ğ‘›) = 2ğ‘› is injective.
â€¢ If ğ‘“(ğ‘›1) = ğ‘“(ğ‘›2), then 2ğ‘›1 = 2ğ‘›2, so ğ‘›1 = ğ‘›2.
âœ“
Example: ğ‘” : â„ â†’ â„ defined by ğ‘”(ğ‘¥) = ğ‘¥3 is injective.
â€¢ The cube function is strictly increasing, so distinct inputs give distinct outputs. âœ“
Example (Computer science applications):
â€¢ Student ID assignment: Each student gets a unique ID number.
â€¢ Hash functions (perfect): Different data should hash to different values (to avoid collisions).
â€¢ Primary keys in databases: Each record must have a unique identifier.
â€¢ Memory addresses: Each memory location has a unique address.
79 / 246
Examples of Non-Injective Functions
Example (Counter-examples (not injective functions)):
â€¢ ğ‘” : â„¤ â†’ â„¤ defined by ğ‘”(ğ‘›) = ğ‘›2 is not injective.
â€£ ğ‘”(âˆ’1) = 1 and ğ‘”(1) = 1, but âˆ’1 â‰  1. âœ—
â€¢ â„ : â„ â†’ â„ defined by â„(ğ‘¥) = sin(ğ‘¥) is not injective.
â€£ â„(0) = â„(ğœ‹) = 0, but 0 â‰  ğœ‹. âœ—
â€¢ ğ‘“ : â„¤ â†’ â„¤5 defined by ğ‘“(ğ‘¥) = ğ‘¥ mod 5 is not injective.
â€£ ğ‘“(2) = ğ‘“(7) = 2, but 2 â‰  7. âœ—
80 / 246
Surjective Functions
Definition 35: A function ğ‘“ : ğ´ â†’ ğµ is surjective (right-total or onto) if every element in the
codomain is the image of at least one element in the domain. Formally:
âˆ€ğ‘ âˆˆ ğµ. âˆƒğ‘ âˆˆ ğ´. ğ‘“(ğ‘) = ğ‘
For surjective functions, Range(ğ‘“) = Cod(ğ‘“), i.e., there are no â€œuncoveredâ€ elements in the right side.
1
ğ‘“
ğ‘“
ğ‘¥
2
ğ‘¦
81 / 246
Examples of Surjective Functions
Key insight: A surjective function â€œcoversâ€ the entire codomain.
Every possible output is actually achieved by some input.
Example: ğ‘“ : â„ â†’ â„ defined by ğ‘“(ğ‘¥) = ğ‘¥3 is surjective.
â€¢ For any ğ‘¦ âˆˆ â„, let ğ‘¥ = 3 âˆšğ‘¦. Then ğ‘“(ğ‘¥) = (3 âˆšğ‘¦)3
= ğ‘¦.
âœ“
Example: ğ‘” : â„ â†’ [0, âˆ) defined by ğ‘”(ğ‘¥) = ğ‘¥2 is surjective.
â€¢ For any ğ‘¦ â‰¥ 0, let ğ‘¥ = âˆšğ‘¦. Then ğ‘”(ğ‘¥) = (âˆšğ‘¦)2
= ğ‘¦.
âœ“
Example: ğ‘“ : â„¤ â†’ â„¤5 defined by ğ‘“(ğ‘¥) = ğ‘¥ mod 5 is surjective.
â€¢ Every element {0, 1, 2, 3, 4} is achieved: ğ‘“(0) = 0, ğ‘“(1) = 1, ğ‘“(2) = 2, ğ‘“(3) = 3, ğ‘“(4) = 4.
Example (Computer science applications):
â€¢ Color quantization: Map 24-bit colors to 8-bit palette (should cover all palette colors).
â€¢ Load balancing: Distribute requests across servers (all servers should be used).
â€¢ Hash table design: Hash function should potentially reach every bucket.
âœ“
82 / 246
Examples of Non-Surjective Functions
Example (Counter-examples (not surjective)):
â€¢ ğ‘” : â„• â†’ â„• defined by ğ‘”(ğ‘›) = 2ğ‘› is not surjective.
â€£ Odd numbers like 3, 5, 7, â€¦ are never achieved since 2ğ‘› is always even. âœ—
â€¢ â„ : â„ â†’ â„ defined by â„(ğ‘¥) = ğ‘¥2 is not surjective.
â€£ Negative numbers like âˆ’1,
âˆ’2,
âˆ’3, â€¦ are never achieved since ğ‘¥2 â‰¥ 0. âœ—
â€¢ ğ‘“ : â„ â†’ â„ defined by ğ‘“(ğ‘¥) = ğ‘’ğ‘¥ is not surjective.
â€£ Negative numbers and zero are never achieved since ğ‘’ğ‘¥ > 0 for all ğ‘¥. âœ—
83 / 246
Bijective Functions
Definition 36: A function ğ‘“ : ğ´ â†’ ğµ is bijective if it is both injective and surjective. A bijective
function establishes a one-to-one correspondence between the elements of ğ´ and ğµ.
Equivelently, ğ‘“ is bijective iff it has an inverse function ğ‘“âˆ’1 : ğµ â†’ ğ´.
Example: ğ‘“ : â„ â†’ â„ defined by ğ‘“(ğ‘¥) = 2ğ‘¥ + 1 is bijective.
â€¢ Injective: If 2ğ‘¥1 + 1 = 2ğ‘¥2 + 1, then ğ‘¥1 = ğ‘¥2.
âœ“
â€¢ Surjective: For any ğ‘¦ âˆˆ â„, let ğ‘¥ = ğ‘¦âˆ’1
2 . Then ğ‘“(ğ‘¥) = ğ‘¦.
âœ“
â€¢ Inverse: ğ‘“âˆ’1(ğ‘¦) = ğ‘¦âˆ’1
2.
Example: ğ‘” : [0, âˆ) â†’ [0, âˆ) defined by ğ‘”(ğ‘¥) = ğ‘¥2 is bijective.
â€¢ Injective: If ğ‘¥2
1 = ğ‘¥2
2 and ğ‘¥1, ğ‘¥2 â‰¥ 0, then ğ‘¥1 = ğ‘¥2.
âœ“
â€¢ Surjective: For any ğ‘¦ â‰¥ 0, let ğ‘¥ = âˆšğ‘¦. Then ğ‘”(ğ‘¥) = ğ‘¦.
âœ“
â€¢ Inverse: ğ‘”âˆ’1(ğ‘¦) = âˆšğ‘¦.
84 / 246
Examples of Bijective Functions
Key insight: Bijective functions are â€œperfect matchingsâ€ between sets. Every element in ğ´ pairs with
exactly one element in ğµ, and vice versa.
Example (Computer science applications):
â€¢ Encryption algorithms: Must be bijective to ensure decryption is possible.
â€¢ Base conversion: Bijection between decimal and binary representations.
â€¢ Perfect hash functions: Bijective mapping from keys to table positions.
â€¢ Coordinate transformations: Reversible mappings between coordinate systems.
85 / 246
Function Composition
Definition 37: Let ğ‘“ : ğ´ â†’ ğµ and ğ‘” : ğµ â†’ ğ¶ be two functions. The composition of ğ‘” and ğ‘“, denoted
ğ‘” âˆ˜ ğ‘“ (read as â€œğ‘” composed with ğ‘“â€ or â€œğ‘” after ğ‘“â€), is a function from ğ´ to ğ¶ defined by:
(ğ‘” âˆ˜ ğ‘“)(ğ‘) = ğ‘”(ğ‘“(ğ‘))
Example: Let ğ‘“ : â„ â†’ â„ be ğ‘“(ğ‘¥) = ğ‘¥2 and ğ‘” : â„ â†’ â„ be ğ‘”(ğ‘¥) = ğ‘¥ + 1.
â€¢ (ğ‘” âˆ˜ ğ‘“)(ğ‘¥) = ğ‘”(ğ‘“(ğ‘¥)) = ğ‘”(ğ‘¥2) = ğ‘¥2 + 1
â€¢ (ğ‘“ âˆ˜ ğ‘”)(ğ‘¥) = ğ‘“(ğ‘”(ğ‘¥)) = ğ‘“(ğ‘¥ + 1) = (ğ‘¥ + 1)2 = ğ‘¥2 + 2ğ‘¥ + 1
Note: ğ‘” âˆ˜ ğ‘“ â‰  ğ‘“ âˆ˜ ğ‘” (composition is not commutative!) ğ‘1
ğ‘1
ğ‘1
ğ‘2
ğ‘2
ğ‘2
ğ‘3
ğ‘3
86 / 246
Examples of Function Composition
Key insight: Function composition is like a â€œpipelineâ€ â€” the output of ğ‘“ becomes the input to ğ‘”.
Read right-to-left: ğ‘” âˆ˜ ğ‘“ means â€œfirst apply ğ‘“, then apply ğ‘”â€, or rather, â€œdo ğ‘” after ğ‘“â€.
Example (Computer science applications):
â€¢ Function pipelines: data |> filter |> map |> reduce
â€¢ Compiler design: lexer â†’ parser â†’ optimizer â†’ code generator
â€¢ Data processing: clean â†’ transform â†’ aggregate â†’ visualize
87 / 246
Properties of Function Composition
â€¢ Associativity: If ğ‘“ : ğ´ â†’ ğµ, ğ‘” : ğµ â†’ ğ¶, and â„ : ğ¶ â†’ ğ·, then (â„ âˆ˜ ğ‘”) âˆ˜ ğ‘“ = â„ âˆ˜ (ğ‘” âˆ˜ ğ‘“).
â€¢ The identity function acts as a neutral element for composition:
â€£ idğµ âˆ˜ ğ‘“ = ğ‘“ for any function ğ‘“ : ğ´ â†’ ğµ.
â€£ ğ‘“ âˆ˜ idğ´ = ğ‘“ for any function ğ‘“ : ğ´ â†’ ğµ.
â€¢ Composition preserves the properties of functions:
â€£ If ğ‘“ and ğ‘” are injective, so is ğ‘” âˆ˜ ğ‘“.
â€£ If ğ‘“ and ğ‘” are surjective, so is ğ‘” âˆ˜ ğ‘“.
â€£ If ğ‘“ and ğ‘” are bijective, so is ğ‘” âˆ˜ ğ‘“.
â€¢ Note that in general, ğ‘” âˆ˜ ğ‘“ â‰  ğ‘“ âˆ˜ ğ‘”, i.e., function composition is not commutative.
88 / 246
Functional Powers
Definition 38: The functional power of ğ‘“ : ğ´ â†’ ğ´ can defined inductively:
ğ‘“0 = idğ´
ğ‘“ğ‘›+1 = ğ‘“ âˆ˜ ğ‘“ğ‘› = ğ‘“ğ‘› âˆ˜ ğ‘“
Note: This definition also works for functions ğ‘“ : ğ‘‹ â†’ ğ‘Œ with ğ‘Œ âŠ† ğ‘‹.
Note: To avoid the confusion with exponential powers (e.g., ğ‘“ğ‘›(ğ‘¥) could be interpreted as (ğ‘“(ğ‘¥))ğ‘›),
we can use the notation ğ‘“âš¬ğ‘› to denote the ğ‘›-th functional power.
Example: Let ğ‘“ : â„ â†’ â„ be ğ‘“(ğ‘¥) = 2ğ‘¥.
â€¢ ğ‘“0(ğ‘¥) = ğ‘¥ (identity)
â€¢ ğ‘“1(ğ‘¥) = 2ğ‘¥
â€¢ ğ‘“2(ğ‘¥) = ğ‘“(ğ‘“(ğ‘¥)) = ğ‘“(2ğ‘¥) = 2(2ğ‘¥) = 4ğ‘¥
â€¢ ğ‘“3(ğ‘¥) = ğ‘“(ğ‘“2(ğ‘¥)) = ğ‘“(4ğ‘¥) = 2(4ğ‘¥) = 8ğ‘¥
â€¢ In general: ğ‘“ğ‘›(ğ‘¥) = 2ğ‘›ğ‘¥
89 / 246
Examples of Functional Powers
Example: Let ğ‘” : â„¤ â†’ â„¤ be ğ‘”(ğ‘¥) = ğ‘¥ + 1 (successor function).
â€¢ ğ‘”âš¬0(ğ‘¥) = ğ‘¥
â€¢ ğ‘”âš¬1(ğ‘¥) = ğ‘¥ + 1
â€¢ ğ‘”âš¬2(ğ‘¥) = ğ‘”(ğ‘”(ğ‘¥)) = ğ‘”(ğ‘¥ + 1) = (ğ‘¥ + 1) + 1 = ğ‘¥ + 2
â€¢ ğ‘”âš¬3(ğ‘¥) = ğ‘”(ğ‘”âš¬2(ğ‘¥)) = ğ‘”(ğ‘¥ + 2) = (ğ‘¥ + 2) + 1 = ğ‘¥ + 3
â€¢ In general: ğ‘”âš¬ğ‘›(ğ‘¥) = ğ‘¥ + ğ‘›
90 / 246
Inverse Functions
Definition 39: If ğ‘“ : ğ´ â†’ ğµ is a bijective function, then its inverse function, denoted ğ‘“âˆ’1 : ğµ â†’ ğ´, is:
ğ‘“âˆ’1(ğ‘) = ğ‘ iff ğ‘“(ğ‘) = ğ‘
Note: A function has an inverse if and only if it is bijective.
Example: Let ğ‘“ : â„ â†’ â„ be ğ‘“(ğ‘¥) = 2ğ‘¥ + 1. We found itâ€™s bijective. To find ğ‘“âˆ’1(ğ‘¦), let ğ‘¦ = 2ğ‘¥ + 1. Solving
for ğ‘¥, we get ğ‘¥ = ğ‘¦âˆ’1
2 . So, ğ‘“âˆ’1(ğ‘¦) = ğ‘¦âˆ’1
2.
Example: The exponential function exp : â„ â†’ (0, âˆ) defined by exp(ğ‘¥) = ğ‘’ğ‘¥ is bijective.
â€¢ Its inverse is the natural logarithm: ln : (0, âˆ) â†’ â„.
â€¢ We have: ln(ğ‘’ğ‘¥) = ğ‘¥ for all ğ‘¥ âˆˆ â„ and ğ‘’ln ğ‘¦ = ğ‘¦ for all ğ‘¦ > 0.
Note: If we tried exp : â„ â†’ â„, it wouldnâ€™t be surjective (negative numbers never achieved), hence no
inverse! The codomain restriction is essential.
91 / 246
Examples of Inverse Functions
Example (Polynomial with domain restriction): Consider ğ‘“ : â„ â†’ â„ defined by ğ‘“(ğ‘¥) = ğ‘¥2
.
â€¢ This is not injective: ğ‘“(âˆ’2) = ğ‘“(2) = 4, so no inverse exists.
However, if we restrict the domain to ğ‘“ : [0, âˆ) â†’ [0, âˆ), then:
â€¢ ğ‘“ becomes bijective (both injective and surjective on non-negative reals).
â€¢ The inverse is ğ‘“âˆ’1(ğ‘¦) = âˆšğ‘¦ for ğ‘¦ â‰¥ 0.
Key insight: Many functions need domain/codomain restrictions to become invertible. This is crucial
in calculus when finding inverse functions!
ğœ‹
2 ,
Example: The sine function sin : â„ â†’ â„ is not injective (itâ€™s periodic), so it has no inverse.
However, with domain restriction, sin : [âˆ’
ğœ‹
2 ] â†’ [âˆ’1, 1] is bijective, with inverse arcsin : [âˆ’1, 1] â†’
[âˆ’
ğœ‹
ğœ‹
2 ].
Similarly: cos : [0, ğœ‹] â†’ [âˆ’1, 1] has inverse arccos, and tan : (âˆ’
ğœ‹
ğœ‹
2 ) â†’ â„ has inverse arctan.
2 ,
2 ,
92 / 246
Characterization of Invertible Functions
Theorem 7: A function ğ‘“ : ğ´ â†’ ğµ has an inverse function ğ‘“âˆ’1 : ğµ â†’ ğ´ if and only if ğ‘“ is bijective.
Proof: We prove both directions.
(â‡’): If ğ‘“ has an inverse, then ğ‘“ is bijective.
Assume ğ‘“âˆ’1 : ğµ â†’ ğ´ is an inverse of ğ‘“ : ğ´ â†’ ğµ with the following properties:
â€¢ ğ‘“âˆ’1(ğ‘“(ğ‘¥)) = ğ‘¥ for all ğ‘¥ âˆˆ ğ´
â€¢ ğ‘“(ğ‘“âˆ’1(ğ‘¦)) = ğ‘¦ for all ğ‘¦ âˆˆ ğµ
We are going to show that ğ‘“ is both injective and surjective.
1. ğ‘“ is injective: Let ğ‘¥1, ğ‘¥2 âˆˆ ğ´ such that ğ‘“(ğ‘¥1) = ğ‘“(ğ‘¥2). Applying ğ‘“âˆ’1 to both sides, we get:
ğ‘“âˆ’1(ğ‘“(ğ‘¥1)) = ğ‘“âˆ’1(ğ‘“(ğ‘¥2))
By the property of the inverse, this simplifies to:
ğ‘¥1 = ğ‘¥2
93 / 246
Characterization of Invertible Functions [2]
Thus, ğ‘“ is injective.
2. ğ‘“ is surjective: Let ğ‘¦ âˆˆ ğµ. We need to find an ğ‘¥ âˆˆ ğ´ such that ğ‘“(ğ‘¥) = ğ‘¦. Take ğ‘¥ = ğ‘“âˆ’1(ğ‘¦). Then by
the property of the inverse, we have:
ğ‘“(ğ‘¥) = ğ‘“(ğ‘“âˆ’1(ğ‘¦)) = ğ‘¦
Hence, ğ‘“ is surjective.
Therefore, ğ‘“ is bijective. âˆ
(â‡): If ğ‘“ is bijective, then ğ‘“ has an inverse ğ‘“âˆ’1
.
Assume ğ‘“ : ğ´ â†’ ğµ is bijective. This means:
â€¢ ğ‘“ is injective: (ğ‘“(ğ‘¥1) = ğ‘“(ğ‘¥2)) â†’ (ğ‘¥1 = ğ‘¥2)
â€¢ ğ‘“ is surjective: for every ğ‘¦ âˆˆ ğµ, there exists ğ‘¥ âˆˆ ğ´ such that ğ‘“(ğ‘¥) = ğ‘¦
We need to construct an inverse function ğ‘“âˆ’1 : ğµ â†’ ğ´, satisfying:
ğ‘“âˆ’1(ğ‘“(ğ‘¥)) = ğ‘¥ and ğ‘“(ğ‘“âˆ’1(ğ‘¦)) = ğ‘¦
94 / 246
Characterization of Invertible Functions [3]
Construction of ğ‘“âˆ’1: For each ğ‘¦ âˆˆ ğµ:
â€¢ Since ğ‘“ is surjective, there exists at least one ğ‘¥ âˆˆ ğ´ such that ğ‘“(ğ‘¥) = ğ‘¦.
â€¢ Since ğ‘“ is injective, this ğ‘¥ is unique.
We define a function ğ‘“âˆ’1 : ğµ â†’ ğ´ by:
ğ‘“âˆ’1(ğ‘¦) = the unique ğ‘¥ âˆˆ ğ´ such that ğ‘“(ğ‘¥) = ğ‘¦
Verification:
1. For all ğ‘¥ âˆˆ ğ´, by definition of ğ‘“âˆ’1:
ğ‘“âˆ’1(ğ‘“(ğ‘¥)) = ğ‘¥
2. For all ğ‘¦ âˆˆ ğµ, since ğ‘“âˆ’1(ğ‘¦) is defined as the unique ğ‘¥ with ğ‘“(ğ‘¥) = ğ‘¦, we have:
ğ‘“(ğ‘“âˆ’1(ğ‘¦)) = ğ‘¦
Therefore, ğ‘“âˆ’1 is indeed the inverse of ğ‘“. âˆ
Thus, a function has an inverse if and only if it is bijective. â–¡
95 / 246
Some Properties of Inverse Functions
Theorem 8: If ğ‘“ : ğ´ â†’ ğµ is a bijective function with inverse ğ‘“âˆ’1 : ğµ â†’ ğ´:
â€¢ ğ‘“âˆ’1 is also bijective.
â€¢ (ğ‘“âˆ’1 âˆ˜ ğ‘“)(ğ‘) = ğ‘ for all ğ‘ âˆˆ ğ´ (i.e., ğ‘“âˆ’1 âˆ˜ ğ‘“ = idğ´).
â€¢ (ğ‘“ âˆ˜ ğ‘“âˆ’1)(ğ‘) = ğ‘ for all ğ‘ âˆˆ ğµ (i.e., ğ‘“ âˆ˜ ğ‘“âˆ’1 = idğµ).
â€¢ If ğ‘“ : ğ´ â†’ ğµ and ğ‘” : ğµ â†’ ğ¶ are both bijective, then (ğ‘” âˆ˜ ğ‘“)âˆ’1 = ğ‘“âˆ’1 âˆ˜ ğ‘”âˆ’1
.
96 / 246
Monotonic Functions
Definition 40: A function ğ‘“ : ğ´ â†’ ğµ is called monotonic if it preserves order relationships.
For real-valued functions ğ‘“ : â„ â†’ â„:
â€¢ Monotonic increasing (or isotone) if ğ‘¥ â‰¤ ğ‘¦ â†’ ğ‘“(ğ‘¥) â‰¤ ğ‘“(ğ‘¦)
â€¢ Strictly increasing if ğ‘¥ < ğ‘¦ â†’ ğ‘“(ğ‘¥) < ğ‘“(ğ‘¦)
â€¢ Monotonic decreasing (or antitone) if ğ‘¥ â‰¤ ğ‘¦ â†’ ğ‘“(ğ‘¥) â‰¥ ğ‘“(ğ‘¦)
â€¢ Strictly decreasing if ğ‘¥ < ğ‘¦ â†’ ğ‘“(ğ‘¥) > ğ‘“(ğ‘¦)
Note: More generally, for any posets âŸ¨ğ´, â‰¤ğ´âŸ© and âŸ¨ğµ, â‰¤ğµâŸ©:
â€¢ ğ‘“ is order-preserving (monotone) if ğ‘¥ â‰¤ğ´ ğ‘¦ â†’ ğ‘“(ğ‘¥) â‰¤ğµ ğ‘“(ğ‘¦)
â€¢ ğ‘“ is order-reversing (antitone) if ğ‘¥ â‰¤ğ´ ğ‘¦ â†’ ğ‘“(ğ‘¥) â‰¥ğµ ğ‘“(ğ‘¦)
97 / 246
Monotonicity implies Injectivity
Theorem 9: If ğ‘“ : â„ â†’ â„ is strictly increasing or strictly decreasing, then ğ‘“ is injective.
Proof: Suppose ğ‘“ is strictly increasing. Let ğ‘¥1, ğ‘¥2 âˆˆ â„ with ğ‘¥1 â‰  ğ‘¥2. Then either ğ‘¥1 < ğ‘¥2 or ğ‘¥2 < ğ‘¥1.
â€¢ If ğ‘¥1 < ğ‘¥2, then ğ‘“(ğ‘¥1) < ğ‘“(ğ‘¥2) by strict monotonicity, so ğ‘“(ğ‘¥1) â‰  ğ‘“(ğ‘¥2).
â€¢ If ğ‘¥2 < ğ‘¥1, then ğ‘“(ğ‘¥2) < ğ‘“(ğ‘¥1) by strict monotonicity, so ğ‘“(ğ‘¥1) â‰  ğ‘“(ğ‘¥2).
In both cases, ğ‘“(ğ‘¥1) â‰  ğ‘“(ğ‘¥2), proving injectivity. The proof for strictly decreasing is analogous. â–¡
Key insights:
â€¢ Monotonic functions have predictable behavior: they never â€œchange directionâ€
â€¢ Strictly monotonic functions are always injective (one-to-one)
â€¢ Non-strict monotonic functions may have â€œflatâ€ regions (also known as â€œplateausâ€) where different
inputs map to the same output
â€¢ Fun fact: monotonic functions are order-homomorphisms between posets!
98 / 246
Examples of Monotonic Functions
Examples: Strictly monotonic functions (which are always injective):
â€¢ ğ‘“(ğ‘¥) = 2ğ‘¥ + 1 is strictly increasing on â„, hence injective. âœ“
â€¢ ğ‘”(ğ‘¥) = âˆ’ğ‘¥ is strictly decreasing on â„, hence injective. âœ“
â€¢ â„(ğ‘¥) = ğ‘¥3 is strictly increasing on â„, hence injective. âœ“
â€¢ ğ‘˜(ğ‘¥) = ğ‘’ğ‘¥ is strictly increasing on â„, hence injective. âœ“
Examples: Monotonic but NOT strictly monotonic functions (not necessarily injective):
â€¢ ğ‘“(ğ‘¥) = âŒŠğ‘¥âŒ‹ is monotonic increasing but NOT strictly increasing.
â€£ For ğ‘¥ âˆˆ [2, 3), we have ğ‘“(ğ‘¥) = 2 (constant on intervals).
â€£ This is NOT injective: ğ‘“(2.1) = ğ‘“(2.9) = 2 but 2.1 â‰  2.9. âœ—
â€¢
ğ‘”(ğ‘¥) = {ğ‘¥ if ğ‘¥â‰¤0
0 if 0<ğ‘¥<1
is monotonic but not injective.
ğ‘¥âˆ’1 if ğ‘¥â‰¥1
Example: ğ‘“ : (â„ âˆ– {0}) â†’ â„ defined by ğ‘“(ğ‘¥) =
1
ğ‘¥
is injective but not monotonic.
â€¢ If ğ‘“(ğ‘¥1) = ğ‘“(ğ‘¥2), then 1
1
=
ğ‘¥1
ğ‘¥2 implies ğ‘¥1 = ğ‘¥2.
âœ“
â€¢ However, ğ‘“ is not monotonic since it decreases on (âˆ’âˆ, 0) and (0, âˆ), but ğ‘“(âˆ’1) < ğ‘“(1). âœ—
99 / 246
Function Properties Overview
Functions can be characterized by several key properties that determine their mathematical behavior.
Property Definition
Functional (Right-unique) Total (Left-total) Partial Injective (Left-unique) Surjective (Right-total) Bijective Monotonic Continuous Each input maps to at most one output
Each input maps to at least one output (defined everywhere)
Functional but not total (may be undefined for some inputs)
Different inputs âŸ¹ different outputs
Every codomain element is covered
Both injective and surjective (one-to-one correspondence)
Preserves or reverses order relationships
Small input changes âŸ¹ small output changes
100 / 246
Characteristic Functions
Definition 41: For any set ğ‘† âŠ† ğ´, the characteristic function (or indicator function) ğœ’ğ‘† : ğ´ â†’ {0, 1} is:
ğœ’ğ‘†(ğ‘¥) = {1 if ğ‘¥ âˆˆ ğ‘†
0 if ğ‘¥ âˆ‰ ğ‘†
This function â€œindicatesâ€ membership in set ğ‘†.
Example: Let ğ´ = {1, 2, 3, 4, 5} and ğ‘† = {2, 4}. Then ğœ’ğ‘† maps:
â€¢ ğœ’ğ‘†(1) = 0 (since 1 âˆ‰ ğ‘†)
â€¢ ğœ’ğ‘†(2) = 1 (since 2 âˆˆ ğ‘†)
â€¢ ğœ’ğ‘†(3) = 0 (since 3 âˆ‰ ğ‘†)
ğœ’ğ‘†(ğ‘¥)
â€¢ ğœ’ğ‘†(4) = 1 (since 4 âˆˆ ğ‘†)
1
â€¢ ğœ’ğ‘†(5) = 0 (since 5 âˆ‰ ğ‘†)
So ğœ’ğ‘† = {(1, 0), (2, 1), (3, 0), (4, 1), (5, 0)}. Elements in ğ‘† = {2, 4} map to 1
0
1 2 3 4 5 ğ‘¥
Elements not in ğ‘† map to 0
101 / 246
Properties of Characteristic Functions
Definition 42: For sets ğ´, ğµ âŠ† ğ‘ˆ:
â€¢ ğœ’ğ´âˆ©ğµ = ğœ’ğ´â‹… ğœ’ğµ (pointwise multiplication)
â€¢ ğœ’ğ´âˆªğµ = ğœ’ğ´ + ğœ’ğµâˆ’ ğœ’ğ´â‹… ğœ’ğµ
â€¢ ğœ’ğ´ = 1 âˆ’ ğœ’ğ´ (complement)
â€¢ ğœ’ğ´â–³ğµ = ğœ’ğ´ + ğœ’ğµâˆ’ 2ğœ’ğ´â‹… ğœ’ğµ (symmetric difference)
â€¢ ğœ’âˆ… = 0 and ğœ’ğ‘ˆ = 1 (constant functions)
Example (Applications):
â€¢ Probability theory: Indicator random variables
â€¢ Database queries: Boolean conditions in WHERE clauses
â€¢ Set operations: Converting logical operations to arithmetic
â€¢ Machine learning: Feature encoding (one-hot encoding)
â€¢ Computer graphics: Masking and selection operations
â€¢ Digital signal processing: Window functions and filters
102 / 246
Floor and Ceiling Functions
Definition 43:
â€¢ Floor function âŒŠ: â„ â†’ â„¤ maps ğ‘¥ to the largest integer â‰¤ ğ‘¥: âŒŠğ‘¥âŒ‹ = max{ğ‘› âˆˆ â„¤ | ğ‘› â‰¤ ğ‘¥}
â€¢ Ceiling function âŒˆ: â„ â†’ â„¤ maps ğ‘¥ to the smallest integer â‰¥ ğ‘¥: âŒˆğ‘¥âŒ‰ = min{ğ‘› âˆˆ â„¤ | ğ‘› â‰¥ ğ‘¥}
Example:
ğ‘¦
ğ‘¥ âŒŠğ‘¥âŒ‹ âŒˆğ‘¥âŒ‰ Note
3.7 3 4 Positive non-integer
âˆ’2.3 âˆ’3 âˆ’2 Negative non-integer
5 5 5 Integer (floor = ceiling)
0 0 0 Zero
âˆ’1 âˆ’1 âˆ’1 Negative integer
âŒˆğ‘¥âŒ‰
âŒŠğ‘¥âŒ‹
ğ‘¥
103 / 246
Summary: Functions
Functions establish relationships between sets where every input has exactly one output:
â€¢ Injective: Different inputs â†’ Different outputs (one-to-one)
â€¢ Surjective: Every output is achieved (onto)
â€¢ Bijective: Both injective and surjective (perfect correspondence)
Key applications in computer science:
â€¢ Database design: Functions model relationships
â€¢ Algorithm analysis: Function properties affect complexity
â€¢ Cryptography: Bijective functions enable encryption/decryption
â€¢ Type systems: Function signatures and type hierarchies
â€¢ Data structures: Mappings, hashing, and uniqueness constraints
104 / 246
Order Theory
â€œOrder is heavenâ€™s first law.â€
â€” Alexander Pope
Helmut Hasse Felix Hausdorff Henri PoincarÃ© Robert Floyd Stephen
Warshall
Stephen Kleene
Orders
Definition 44: A relation ğ‘… âŠ† ğ‘€2 is called a preorder if it is reflexive and transitive.
Definition 45: A partial order is a relation ğ‘… âŠ† ğ‘€2 that is reflexive, antisymmetric, and transitive.
Definition 46: A linear order is a partial order ğ‘… âŠ† ğ‘€2 where every pair of elements is comparable:
âˆ€ğ‘¥, ğ‘¦ âˆˆ ğ‘€. (ğ‘¥ ğ‘… ğ‘¦ âˆ¨ ğ‘¦ ğ‘… ğ‘¥)
Note: The above condition is called strong connectivity. The similar property with the ğ‘¥ â‰  ğ‘¦ condition is
called semi-connectivity. The corresponding relations are called connex and semi-connex.
Note: Hereinafter, we mainly study the â€œnon-strictâ€ orders (e.g., â‰¤, âŠ†), which require the reflexivity.
The â€œstrictâ€ orders (e.g., <, âŠ‚) require irreflexivity instead, and are defined similarly.
Note: Strict linear orders require semi-connectivity instead, since connectivity alone implies reflexivity!
106 / 246
Examples of Orders
Example: The relation â‰¤ on real numbers â„ is a total order:
â€¢ Reflexive: ğ‘¥ â‰¤ ğ‘¥ for all ğ‘¥ âˆˆ â„ âœ“
â€¢ Antisymmetric: If ğ‘¥ â‰¤ ğ‘¦ and ğ‘¦ â‰¤ ğ‘¥, then ğ‘¥ = ğ‘¦ âœ“
â€¢ Transitive: If ğ‘¥ â‰¤ ğ‘¦ and ğ‘¦ â‰¤ ğ‘§, then ğ‘¥ â‰¤ ğ‘§ âœ“
â€¢ Connected: For any ğ‘¥, ğ‘¦ âˆˆ â„, either ğ‘¥ â‰¤ ğ‘¦ or ğ‘¦ â‰¤ ğ‘¥ âœ“
This is the most familiar example of an order relation. Similarly, â„•, â„¤, and â„š with â‰¤ are all total orders.
âˆ’1 â‰¤ 2
âˆ’4 âˆ’3 âˆ’2 âˆ’1 0 1 2 3 4âˆ’âˆ +âˆâˆ’3 â‰¤ âˆ’1
âˆ’2 â‰¤ 1
0 â‰¤ 3
Linear order â‰¤ on real numbers â„
107 / 246
Examples of Orders [2]
Example: The subset relation âŠ† on the power set ğ’«ï¸€(ğ´) is a partial order.
Verification:
â€¢ Reflexive: ğ‘‹ âŠ† ğ‘‹ for all ğ‘‹ âŠ† ğ´ âœ“
â€£ Every set is a subset of itself by definition
â€¢ Antisymmetric: If ğ‘‹ âŠ† ğ‘Œ and ğ‘Œ âŠ† ğ‘‹, then ğ‘‹ = ğ‘Œ âœ“
â€£ If every element of ğ‘‹ is in ğ‘Œ , and every element of ğ‘Œ is in ğ‘‹, then ğ‘‹ and ğ‘Œ have the same elements
â€¢ Transitive: If ğ‘‹ âŠ† ğ‘Œ and ğ‘Œ âŠ† ğ‘, then ğ‘‹ âŠ† ğ‘ âœ“
â€£ If every element of ğ‘‹ is in ğ‘Œ , and every element of ğ‘Œ is in ğ‘, then every element of ğ‘‹ is in ğ‘
For ğ´ = {1, 2}, we have ğ’«ï¸€(ğ´) = {âˆ…, {1}, {2}, {1, 2}} with:
â€¢ âˆ… âŠ† {1} âŠ† {1, 2} (this is a chain)
â€¢ âˆ… âŠ† {2} âŠ† {1, 2} (another chain)
â€¢ But {1} and {2} are incomparable (neither is a subset of the other)
This is not a total order because not all pairs are comparable.
108 / 246
Examples of Orders [3]
Example: Consider the no longer than relation â‰¼ on binary strings ğ”¹âˆ—:
ğ‘¥ â‰¼ ğ‘¦ iff len(ğ‘¥) â‰¤ len(ğ‘¦)
Verification:
â€¢ Reflexive: ğ‘¥ â‰¼ ğ‘¥ for all ğ‘¥ âˆˆ ğ”¹âˆ— âœ“
â€£ len(ğ‘¥) â‰¤ len(ğ‘¥) is always true
â€¢ Transitive: If ğ‘¥ â‰¼ ğ‘¦ and ğ‘¦ â‰¼ ğ‘§, then ğ‘¥ â‰¼ ğ‘§ âœ“
â€£ If len(ğ‘¥) â‰¤ len(ğ‘¦) and len(ğ‘¦) â‰¤ len(ğ‘§), then len(ğ‘¥) â‰¤ len(ğ‘§) by transitivity of â‰¤
â€¢ Antisymmetric: âœ—
â€£ Counter-example: 01 â‰¼ 10 and 10 â‰¼ 01 (since both have length 2), but 01 â‰  10
â€¢ Connected: For any ğ‘¥, ğ‘¦ âˆˆ ğ”¹âˆ—, either ğ‘¥ â‰¼ ğ‘¦ or ğ‘¦ â‰¼ ğ‘¥ âœ“
â€£ Either len(ğ‘¥) â‰¤ len(ğ‘¦) or len(ğ‘¦) â‰¤ len(ğ‘¥) (or both)
This is a preorder (reflexive and transitive), and even connected, but not a partial order due to lack of
antisymmetry. Different strings of the same length are all â€œequivalentâ€ under this relation, but theyâ€™re not
actually equal.
109 / 246
Examples of Orders [4]
Example: Divisibility | on positive integers â„•+ is a partial order.
Verification:
â€¢ Reflexive: ğ‘› | ğ‘› for all ğ‘› âˆˆ â„•+ (every number divides itself) âœ“
â€¢ Antisymmetric: If ğ‘ | ğ‘ and ğ‘ | ğ‘, then ğ‘ = ğ‘ âœ“
â€£ If ğ‘ divides ğ‘, then ğ‘ = ğ‘ğ‘˜ for some positive integer ğ‘˜
â€£ If ğ‘ divides ğ‘, then ğ‘ = ğ‘â„“ for some positive integer â„“
â€£ Substituting: ğ‘ = ğ‘ğ‘˜ = (ğ‘â„“)ğ‘˜ = ğ‘ğ‘˜â„“, so ğ‘˜â„“ = 1
â€£ Since ğ‘˜, â„“ âˆˆ â„•+, we must have ğ‘˜ = â„“ = 1, hence ğ‘ = ğ‘
â€¢ Transitive: If ğ‘ | ğ‘ and ğ‘ | ğ‘, then ğ‘ | ğ‘ âœ“
â€£ If ğ‘ | ğ‘, then ğ‘ = ğ‘ğ‘˜ for some integer ğ‘˜
â€£ If ğ‘ | ğ‘, then ğ‘ = ğ‘â„“ for some integer â„“
â€£ Therefore: ğ‘ = ğ‘â„“ = (ğ‘ğ‘˜)â„“ = ğ‘(ğ‘˜â„“), so ğ‘ | ğ‘
â€¢ Connected: âœ—
â€£ Counter-example: 2 does not divide 3, and 3 does not divide 2
This is a partial order but not a total order because some pairs are incomparable.
110 / 246
Examples of Orders [5]
Example: Lexicographic order on strings ğ´ğ‘› (like dictionary order) is a total order.
Verification:
â€¢ Reflexive: ğ‘  âª¯ ğ‘  for all strings ğ‘  âœ“
â€£ A string is lexicographically equal to itself
â€¢ Antisymmetric: If ğ‘  âª¯ ğ‘¡ and ğ‘¡ âª¯ ğ‘ , then ğ‘  = ğ‘¡ âœ“
â€£ If ğ‘  comes before or equals ğ‘¡ AND ğ‘¡ comes before or equals ğ‘ , then ğ‘  = ğ‘¡
â€¢ Transitive: If ğ‘  âª¯ ğ‘¡ and ğ‘¡ âª¯ ğ‘¢, then ğ‘  âª¯ ğ‘¢ âœ“
â€£ Lexicographic comparison preserves transitivity through character-by-character comparison
â€¢ Connected: For any strings ğ‘ , ğ‘¡, either ğ‘  âª¯ ğ‘¡ or ğ‘¡ âª¯ ğ‘  âœ“
â€£ We can always compare strings lexicographically by comparing character by character
For binary strings of length 2: 00 â‰º 01 â‰º 10 â‰º 11
Key property: Every pair of strings is comparable, making this a total order.
111 / 246
Partially Ordered Sets
Definition 47: A partially ordered set (or poset) âŸ¨ğ‘†, â‰¤âŸ© is a set ğ‘† equipped with a partial order â‰¤.
Example: Consider the poset âŸ¨ğ·, |âŸ© where ğ· = {1, 2, 3, 4, 6, 12} and | is divisibility.
Order relation properties:
â€¢ Reflexive: ğ‘› | ğ‘› for all ğ‘› âˆˆ ğ·
â€¢ Antisymmetric: If ğ‘ | ğ‘ and ğ‘ | ğ‘, then ğ‘ = ğ‘
â€¢ Transitive: If ğ‘ | ğ‘ and ğ‘ | ğ‘, then ğ‘ | ğ‘
12
4 6
Special elements:
â€¢ Least element: 1 (divides all others)
â€¢ Greatest element: 12 (divisible by all others)
â€¢ Minimal elements: just 1
â€¢ Maximal elements: just 12
2 3
1
Note: This poset forms a lattice since every pair has a supremum (LCM) and infimum (GCD).
112 / 246
Hasse Diagrams
Definition 48: A Hasse diagram is a visual representation of a poset where:
â€¢ Each element is represented as a vertex.
â€¢ If ğ‘¥ < ğ‘¦ and there is no ğ‘§ with ğ‘¥ < ğ‘§ < ğ‘¦, draw an edge from ğ‘¥ to ğ‘¦.
â€¢ Elements are arranged vertically by the order relation.
â€¢ Transitive connections are omitted (implied by transitivity of the partial order).
Example: For ğ· = {1, 2, 3, 4, 5, 10, 20, 35} with divisibility |.
Reading the diagram:
â€¢ 1 divides everything (least element at bottom)
â€¢ Multiple maximal elements: 3, 20, 35 (no single greatest element)
â€¢ Some chains (not necessarily maximal, can skip elements):
â€£ Chain: 1 | 2 | 4 (powers of 2)
â€£ Chain: 1 | 10 | 20 (multiples of 10)
â€£ Chain: 5 | 35 (multiples of 5)
â€¢ Primes 2, 3, 5 are incomparable to each other
20
4 10 35
2 3 5
1
113 / 246
Subset Poset
Example: For ğ’«ï¸€({ğ‘, ğ‘}) = {âˆ…, {ğ‘}, {ğ‘}, {ğ‘, ğ‘}} with inclusion âŠ†:
{ğ‘, ğ‘}
{ğ‘} {ğ‘}
âˆ…
Note: This is the classic â€œdiamondâ€ shape characteristic of Boolean algebras.
Note: âŸ¨ğ’«ï¸€(ğ´), âŠ†âŸ© is also called the Boolean lattice.
114 / 246
Covering Relation
Definition 49: In a poset âŸ¨ğ‘†, â‰¤âŸ©, an element ğ‘¦ âˆˆ ğ‘† covers ğ‘¥ âˆˆ ğ‘†, denoted ğ‘¥ â‹– ğ‘¦, if there is no other
element in between them:
ğ‘¥ â‹– ğ‘¦ iff Note: â€œ<â€ denotes the induced strict order:
ğ‘¥ < ğ‘¦ iff Note: Hasse diagram is just a graph of a covering relation!
(ğ‘¥ < ğ‘¦) âˆ§ âˆ„ğ‘§ âˆˆ ğ‘†. (ğ‘¥ < ğ‘§ < ğ‘¦)
(ğ‘¥ â‰¤ ğ‘¦) âˆ§ (ğ‘¥ â‰  ğ‘¦)
115 / 246
Maximal and Minimal Elements
Definition 50: An element ğ‘š âˆˆ ğ‘† is called a maximal element of a poset âŸ¨ğ‘†, â‰¤âŸ© if it is not less than
any other element, i.e., there is no even greater element.
âˆ€ğ‘¥ â‰  ğ‘š.
Â¬(ğ‘š â‰¤ ğ‘¥) âŸº âˆ„ğ‘¥ â‰  ğ‘š. (ğ‘š â‰¤ ğ‘¥)
Equivelently, âˆ€ğ‘¥ âˆˆ ğ‘†. (ğ‘š â‰¤ ğ‘¥) â†’ (ğ‘š = ğ‘¥)
Definition 51: An element ğ‘š âˆˆ ğ‘† is called a minimal element of a poset âŸ¨ğ‘†, â‰¤âŸ© if it is not greater than
any other element, i.e., there is no even smaller element.
âˆ€ğ‘¥ â‰  ğ‘š.
Â¬(ğ‘¥ â‰¤ ğ‘š) âŸº âˆ„ğ‘¥ â‰  ğ‘š. (ğ‘¥ â‰¤ ğ‘š)
Equivelently, âˆ€ğ‘¥ âˆˆ ğ‘†. (ğ‘¥ â‰¤ ğ‘š) â†’ (ğ‘¥ = ğ‘š)
Note: There may be multiple maximal (or minimal) elements.
116 / 246
Example of Maximal and Minimal Elements
Example: Consider the divisibility poset on ğ‘† = {2, 3, 4, 6, 8, 12}:
Maximal elements: 8 and 12
â€¢ 8 divides nothing else in ğ‘† except itself
â€¢ 12 divides nothing else in ğ‘† except itself
Minimal elements: 2 and 3
â€¢ Nothing in ğ‘† properly divides 2 (since 1 âˆ‰ ğ‘†)
â€¢ Nothing in ğ‘† properly divides 3
Note: This poset has no greatest or least element, but multiple minimal/maximal elements.
Hasse diagram:
â€¢ Maximal elements (8, 12) â€” they divide nothing else in ğ‘†
â€¢ Minimal elements (2, 3) â€” nothing in ğ‘† divides them
â€¢ Two separate chains: 2 | 4 | 8 and 3 | 6 | 12
8 12
4 6
2 3
117 / 246
Example of Maximal and Minimal Elements [2]
Example: Let ğ‘† = {ab, abc, abd, ac, b, bc} ordered by the prefix relation â‹–:
ğ‘¥ â‹– ğ‘¦ iff ğ‘¥ is a prefix of ğ‘¦
Maximal elements: abc, abd, ac, bc
â€¢ These strings are not prefixes of any other string in ğ‘†
Minimal elements: ab, ac, b
â€¢ These strings have no other string in ğ‘† that is a proper prefix of them
The Hasse diagram shows three separate â€œtreesâ€ rooted at the minimal elements, with:
â€¢ ab â‹– abc and ab â‹– abd
â€¢ b â‹– bc
â€¢ ac stands alone (no other string extends it in ğ‘†)
â€œabcâ€ â€œabdâ€
â€œacâ€
Maximal elements
Minimal elements
Both minimal & maximal
â€œabâ€
â€œbcâ€
â€œbâ€
118 / 246
Greatest and Least Elements
Definition 52: The greatest element of a poset âŸ¨ğ‘†, â‰¤âŸ© is an element ğ‘” âˆˆ ğ‘† that is greater than or equal
to every other element in ğ‘†, i.e., for all ğ‘¥ âˆˆ ğ‘†, ğ‘¥ â‰¤ ğ‘”.
Definition 53: A least element (bottom) ğ‘ satisfies ğ‘ â‰¤ ğ‘¥ for all ğ‘¥ âˆˆ ğ‘†.
Note: Greatest (top) and least (bottom) elements are unique when they exist.
Examples:
â€¢ âŸ¨ğ’«ï¸€(ğ´), âŠ†âŸ©: least âˆ… (contained in every set), greatest ğ´ (contains every subset).
â€¢ âŸ¨â„•+
, |âŸ©: least 1 (divides every positive integer), no greatest element (no integer is divisible by all others).
â€¢ âŸ¨â„¤, â‰¤âŸ©: no least or greatest element (integers extend infinitely in both directions).
â€¢ âŸ¨{1, 2, 3, 4, 5, 6}, |âŸ©: least 1, no greatest element, maximal elements are 4, 5, 6 (prime powers and primes
that donâ€™t divide anything else in the given set).
119 / 246
Converse Orders
Definition 54: The dual (or converse) of a poset âŸ¨ğ‘†, â‰¤âŸ© is the poset âŸ¨ğ‘†, â‰¥âŸ© where ğ‘¥ â‰¥ ğ‘¦ iff ğ‘¦ â‰¤ ğ‘¥.
Example: Consider the â„•+ ordered naturally.
â€¢ For â‰¤ order:
â€£ The â‰¤-least element is 1, since it is â‰¤-smaller than all others.
â€£ 1 is also â‰¤-minimal, since there are no other element which is â‰¤-smaller than 1.
â€£ There are no â‰¤-maximal elements, since the set is unbounded above.
â€£ On the Hasse diagram, 1 is at the bottom, and the diagram extends infinitely upwards.
â€¢ For â‰¥ order, minimal and maximal elements â€œflipâ€:
â€£ There are no â‰¥-minimal elements. A â‰¥-minimal element would be an element ğ‘š such that there is no
other (â‰¥-smaller) element ğ‘› â‰  ğ‘š with ğ‘› â‰¥ ğ‘š. However, for any ğ‘š âˆˆ â„•+, there exists ğ‘› = ğ‘š + 1
which is ğ‘› â‰¥ ğ‘š, so no such â‰¥-minimal element exists.
â€£ The â‰¥-greatest element is 1, since all elements are â‰¥-smaller than it.
â€£ On the Hasse diagram, 1 is at the top, and the diagram extends infinitely downwards.
120 / 246
Notes on Converse Orders
Note:
â€¢ Maximal elements in âŸ¨ğ‘†, â‰¤âŸ© become minimal in âŸ¨ğ‘†, â‰¥âŸ© and vice versa.
â€¢ Greatest element in âŸ¨ğ‘†, â‰¤âŸ© becomes least in âŸ¨ğ‘†, â‰¥âŸ© and vice versa.
â€¢ Chains and antichains remain the same in both orders.
â€¢ The Hasse diagram is flipped vertically when taking the dual order.
â€£ For âŸ¨â„•+
, â‰¤âŸ©:
- The least element 1 is at the bottom.
- The diagram of âŸ¨â„•+
, â‰¤âŸ© extends infinitely upwards.
â€£ In the dual âŸ¨â„•+
, â‰¥âŸ©:
- 1 becomes the greatest element at the top.
- The diagram of âŸ¨â„•+
, â‰¥âŸ© extends infinitely downwards.
121 / 246
Chains and Antichains
Definition 55: In a partially ordered set âŸ¨ğ‘€, â‰¤âŸ©:
â€¢ A chain is a subset ğ¶ âŠ† ğ‘€ where every two elements are comparable. Formally:
âˆ€ğ‘¥, ğ‘¦ âˆˆ ğ¶. (ğ‘¥ â‰¤ ğ‘¦ or ğ‘¦ â‰¤ ğ‘¥)
â€¢ An antichain is a subset ğ´ âŠ† ğ‘€ where no two distinct elements are comparable. Formally:
âˆ€ğ‘¥, ğ‘¦ âˆˆ ğ´. (ğ‘¥ â‰  ğ‘¦) â†’ (ğ‘¥ â‰° ğ‘¦ and ğ‘¦ â‰° ğ‘¥)
Note:
â€¢ Chains correspond to arbitrary paths or sub-sequences in the Hasse diagram.
â€¢ A maximal chain is a chain that cannot be extended by including any other elements from ğ‘€.
â€¢ A maximum chain is a chain of the largest possible size in ğ‘€.
â€¢ A chain is a totally ordered subset of the poset.
â€¢ An antichain consists of pairwise incomparable elements.
â€¢ Any singleton set is both a chain and an antichain.
122 / 246
Examples of Chains and Antichains
Example: Consider the divisibility poset âŸ¨ğ·, |âŸ© where ğ· = {1, 2, 3, 4, 5, 6, 10, 20, 35}.
Chains: (totally ordered subsets)
â€¢ Maximal chain: {1, 2, 4, 20} â€” longest path
â€¢ Not maximal: {5, 10}
â€¢ Can skip elements: {1, 5, 20}
Maximal elements: 3, 20, 35
Antichains: (pairwise incomparable elements)
â€¢ Maximal antichain: {3, 4, 10, 35}
â€¢ Incomparable on the same level: {2, 5}
â€¢ Incomparable from different levels: {3, 2, 35}
3
4
2
20
1
10
5
Dilworthâ€™s theorem: Maximum antichain size (4) = minimum chains needed to cover (4).
35
123 / 246
Examples of Chains and Antichains [2]
Example: In a Git repository, commits form a poset under the â€œancestorâ€ relation:
â€¢ Chain: A sequence of commits on a single branch (linear history).
â€¢ Antichain: Commits on different branches that have diverged (no ancestry relation).
Practical insight: Merge commits combine multiple antichains back into a single chain.
124 / 246
Chains and Antichains in Scheduling
Example: In project management, tasks form a scheduling poset under the â€œprerequisiteâ€ relation.
Consider web development tasks: Design, Backend, Frontend, Testing, Deploy, Documentation.
Dependencies:
â€¢ Design â‰º Back, Front
â€¢ Back, Front â‰º Test
â€¢ Test â‰º Deploy â‰º Doc
Documentation
Backend
Design
Testing Deploy
Antichain analysis:
â€¢ {Back, Front} can run in parallel after Design
â€¢ {Deploy, Doc} can run in parallel (final tasks)
Frontend
Critical path: Design â†’ Back â†’ Test â†’ Deploy (length 3 max chain)
Practical insights:
â€¢ Chains = sequential dependencies (critical path)
â€¢ Antichains = tasks for parallel execution (resource allocation)
â€¢ Project duration = length of longest chain
125 / 246
Dilworthâ€™s Theorem
Theorem 10 (Dilworth): In any finite partially ordered set, the maximum size of an antichain equals
the minimum number of chains needed to cover the entire set.
Example: Consider the divisibility poset on ğ‘ƒ = {2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60}.
60
Maximum antichain: {4, 6, 10, 15} (size 4)
â€¢ These elements are pairwise incomparable (none divides another).
12 20 30
Minimum chain decomposition: We need exactly 4 chains that cover ğ‘ƒ:
â€¢ Chain 1: 2 | 4 | 12 | 60
â€¢ Chain 2: 3 | 6 | 30
â€¢ Chain 3: 5 | 10 | 20
â€¢ Chain 4: 15 (singleton chain)
4 6 10 15
2 3 5
Each element appears in exactly one chain, forming a partition of ğ‘ƒ.
Dilworthâ€™s theorem: Maximum antichain size (4) = Minimum number of disjoint chains (4). âœ“
126 / 246
Proof of Dilworthâ€™s Theorem
Proof: Let âŸ¨ğ‘ƒ, â‰¤âŸ© be a finite poset. Let ğ›¼ denote the maximum size of an antichain in ğ‘ƒ, and let ğ›½ denote
the minimum number of chains needed to cover ğ‘ƒ. We prove ğ›¼ = ğ›½ by showing ğ›¼ â‰¤ ğ›½ and ğ›¼ â‰¥ ğ›½.
Easy part (ğ›¼ â‰¤ ğ›½): Suppose ğ‘ƒ can be partitioned into ğ‘˜ chains ğ¶1, â€¦, ğ¶ğ‘˜. Let ğ´ be any antichain in ğ‘ƒ.
Since elements in an antichain are pairwise incomparable, each chain contains at most one element of ğ´.
Therefore |ğ´| â‰¤ ğ‘˜. Taking the maximum over all antichains gives ğ›¼ â‰¤ ğ‘˜. Since this holds for any chain
partition, we have ğ›¼ â‰¤ ğ›½. âˆ
127 / 246
Proof of Dilworthâ€™s Theorem [2]
Hard part (ğ›¼ â‰¥ ğ›½): Let ğ´ âŠ† ğ‘ƒ be a maximal antichain of size ğ›¼.
We construct a chain partition of ğ‘ƒ of size ğ›¼ as follows:
â€¢ Initialize ğ’ï¸€ â‰” âˆ….
â€¢ While ğ‘ƒ â‰  âˆ…:
1. Choose a maximal element ğ‘¥ âˆˆ ğ‘ƒ (no element above ğ‘¥ in the remaining poset).
2. Build a chain ğ¶ ending at ğ‘¥:
â€£ Start with ğ¶ â‰” {ğ‘¥}.
â€£ Repeatedly add a maximal predecessor element ğ‘¦ âˆˆ ğ‘ƒ âˆ– ğ¶ such that ğ‘¦ < current bottom of ğ¶.
3. Add ğ¶ to ğ’ï¸€ and remove all elements of ğ¶ from ğ‘ƒ.
By construction:
â€¢ Each ğ¶ âˆˆ ğ’ï¸€ is a chain (elements are added only below the current bottom).
â€¢ Chains in ğ’ï¸€ cover all elements of ğ‘ƒ.
â€¢ Each chain contains exactly one element of the maximal antichain ğ´, so |ğ’ï¸€| = ğ›¼.
Therefore ğ‘ƒ can be covered by ğ›¼ chains, giving ğ›½ â‰¤ ğ›¼. â–¡
128 / 246
Summary: Orders
Orders provide structured ways to compare and rank elements:
â€¢ Preorders: Basic comparison (reflexive, transitive)
â€¢ Partial orders: Add antisymmetry for unique comparisons
â€¢ Total orders: Every pair of elements is comparable
Visualization: Hasse diagrams clearly show structure and hierarchy by omitting redundant transitive
edges, revealing chains (ordered sequences) and antichains (incomparable elements).
Applications: Task scheduling â€¢ Git version control â€¢ Database indexing â€¢ Type hierarchies â€¢ Boolean
algebra â€¢ Concurrent systems â€¢ Build systems (dependency resolution) â€¢ Social networks â€¢ File system
permissions â€¢ Web page ranking â€¢ Package managers â€¢ Distributed systems
129 / 246
Lattices
â€œOrder is the shape upon which beauty depends.â€
â€” Pearl S. Buck
Alfred Tarski Garrett
Birkhoff
Dana Scott Emmy Noether Marshall Stone
Upper and Lower Bounds
Definition 56: In a poset âŸ¨ğ‘†, â‰¤âŸ©, an element ğ‘¢ âˆˆ ğ‘† is called an upper bound of a subset ğ¶ âŠ† ğ‘† if it is
greater than or equal to every element in ğ¶, i.e., for all ğ‘¥ âˆˆ ğ¶, ğ‘¥ â‰¤ ğ‘¢.
Definition 57: In a poset âŸ¨ğ‘†, â‰¤âŸ©, an element ğ‘™ âˆˆ ğ‘† is called a lower bound of a subset ğ¶ âŠ† ğ‘† if it is
less than or equal to every element in ğ¶, i.e., for all ğ‘¥ âˆˆ ğ¶, ğ‘™ â‰¤ ğ‘¥.
Note: In the simplest case, we consider a single-element subset: the upper/lower bounds of ğ¶ = {ğ‘} are
just all elements greater/less than ğ‘ (including ğ‘ itself, since ğ‘ â‰¤ ğ‘). In a more general case, upper/lower
bounds must be comparable to all elements in ğ¶.
131 / 246
Examples of Bounds
Example: In âŸ¨â„¤, â‰¤âŸ© for ğ¶ = {âˆ’2, 3, 7}:
â€¢ Lower bounds: all integers â‰¤ âˆ’2, i.e., {â€¦,
âˆ’4,
âˆ’3,
âˆ’2}
â€¢ Upper bounds: all integers â‰¥ 7, i.e., {7, 8, 9, â€¦}
Example: In âŸ¨â„, â‰¤âŸ© for interval ğ¶ = (0; 1):
â€¢ Lower bounds: every ğ‘¥ â‰¤ 0 (including âˆ’âˆ,
âˆ’1, 0)
â€¢ Upper bounds: every ğ‘¥ â‰¥ 1 (including 1, 2, +âˆ)
Example: In âŸ¨ğ’«ï¸€({1, 2, 3}), âŠ†âŸ© for ğ¶ = {{1, 2}, {1, 3}}:
â€¢ Lower bounds: âˆ…, {1} (subsets of both sets in ğ¶)
â€¢ Upper bounds: {1, 2, 3} (supersets of both sets in ğ¶)
Example: In divisibility poset for ğ¶ = {4, 6}:
â€¢ Upper bounds: multiples of lcm(4, 6) = 12, i.e., {12, 24, 36, â€¦}
â€¢ Lower bounds: common divisors, i.e., {1, 2}
132 / 246
Suprema and Infima
Definition 58: In a poset âŸ¨ğ‘†, â‰¤âŸ©, the supremum (or join) of a subset ğ¶ âŠ† ğ‘†, denoted sup(ğ¶) or â‹ ğ¶, is
the least upper bound of ğ¶, i.e., an upper bound ğ‘¢ âˆˆ ğ‘† s.t. for any other upper bound ğ‘£ âˆˆ ğ‘†, ğ‘¢ â‰¤ ğ‘£.
Note: If it exists, the least upper bound is unique.
Definition 59: In a poset âŸ¨ğ‘†, â‰¤âŸ©, the infimum (or meet) of a subset ğ¶ âŠ† ğ‘†, denoted inf(ğ¶) or â‹€ ğ¶, is
the greatest lower bound of ğ¶, i.e., a lower bound ğ‘™ âˆˆ ğ‘† s.t. for any other lower bound ğ‘š âˆˆ ğ‘†, ğ‘š â‰¤ ğ‘™.
Note: If it exists, the greatest lower bound is unique.
Example: âŸ¨â„, â‰¤âŸ©:
â€¢ For finite subsets, sup(ğ¶) = max(ğ¶) and inf(ğ¶) = min(ğ¶).
â€¢ For infinite subsets: sup((0; 1)) = 1 and inf((0; 1)) = 0 (even though 0, 1 âˆ‰ (0; 1))
133 / 246
Examples of Suprema and Infima
Example: âŸ¨ğ’«ï¸€(ğ´), âŠ†âŸ©:
â€¢ Join: sup(ğ’ï¸€) = â‹ƒğ‘‹âˆˆğ’ï¸€ ğ‘‹ (union of all sets)
â€¢ Meet: inf(ğ’ï¸€) = â‹‚ğ‘‹âˆˆğ’ï¸€ ğ‘‹ (intersection of all sets)
â€¢ sup{{1, 2}, {2, 3}, {3, 4}} = {1, 2, 3, 4}
â€¢ inf{{1, 2, 3}, {2, 3, 4}, {3, 4, 5}} = {3}
Example: Divisibility on â„•+:
â€¢ Join: sup{ğ‘, ğ‘} = lcm(ğ‘, ğ‘) (least common multiple)
â€¢ Meet: inf{ğ‘, ğ‘} = gcd(ğ‘, ğ‘) (greatest common divisor)
â€¢ sup{6, 10} = 30
â€¢ inf{6, 10} = 2
134 / 246
Lattices
Definition 60: A poset âŸ¨ğ‘†, â‰¤âŸ© where every non-empty finite subset ğ¶ âŠ† ğ‘† has a join (supremum) is
called an upper semilattice (or join-semilattice) and denoted âŸ¨ğ‘†, âˆ¨âŸ©.
Definition 61: A poset âŸ¨ğ‘†, â‰¤âŸ© where every non-empty finite subset ğ¶ âŠ† ğ‘† has a meet (infimum) is
called a lower semilattice (or meet-semilattice) and denoted âŸ¨ğ‘†, âˆ§âŸ©.
Definition 62: A poset âŸ¨ğ‘†, â‰¤âŸ© that is both an upper semilattice and a lower semilattice, i.e., every non-
empty finite subset has both a join and a meet, is called a lattice, denoted (ğ‘†, âˆ¨, âˆ§).
Example (Boolean Lattice): âŸ¨ğ’«ï¸€(ğ‘‹), âŠ†âŸ© is a bounded distributive lattice (ğ’«ï¸€(ğ‘‹), âˆª, âˆ©):
â€¢ Elements are subsets of ğ‘‹, ordered by inclusion (âŠ†)
â€¢ Join is union (âˆ¨ = âˆª), meet is intersection (âˆ§ = âˆ©)
â€¢ Top element is ğ‘‹ (greatest element), bottom is âˆ… (least element)
135 / 246
Examples: Small Lattices
Boolean Lattice ğµ1
âŠ¤
Diamond Lattice ğ‘€3
âŠ¤
Pentagon Lattice ğ‘5
âŠ¤
ğ‘ ğ‘ ğ‘
ğ‘
âŠ¥
ğ‘
ğ‘
âŠ¥
âŠ¥
Operations:
â€¢ âŠ¤ âˆ¨ âŠ¤ = âŠ¤
â€¢ âŠ¥ âˆ¨ âŠ¥ = âŠ¥
â€¢ âŠ¥ âˆ¨ âŠ¤ = âŠ¤
â€¢ âŠ¥ âˆ§ âŠ¤ = âŠ¥
â€¢ Smallest non-distributive
â€¢ But modular!
Smallest non-modular: for ğ‘ â‰¤ ğ‘:
ğ‘ âˆ¨ (ğ‘ âˆ§ ğ‘) = ğ‘
(ğ‘ âˆ¨ ğ‘) âˆ§ ğ‘ = ğ‘} ğ‘ â‰  ğ‘ âœ—
Key insight: These small lattices are fundamental building blocks. Many properties (distributivity,
modularity) can be characterized by whether these appear as sublattices.
136 / 246
Counterexamples: Not All Posets Are Lattices!
No Supremum
âŠ¤
ğ‘¡1 ğ‘¡2
No Infimum
ğ‘¥ ğ‘¦
No Bounds
ğ‘¥ ğ‘¦
{ğ‘¥, ğ‘¦} does not have any
upper/lower bounds
Not a lattice âœ—
ğ‘¥ ğ‘¦
{ğ‘¥, ğ‘¦} has two minimal
upper bounds: ğ‘¡1 and ğ‘¡2
Not a lattice âœ—
ğ‘1 ğ‘2
âŠ¥
{ğ‘¥, ğ‘¦} has two maximal
lower bounds: ğ‘1 and ğ‘2
Not a lattice âœ—
Warning: A poset must have unique least upper bounds and greatest lower bounds for every pair of
elements to be a lattice. Even one missing join or meet makes it not a lattice!
137 / 246
Why Lattices?
Why study lattices? Whenever you have:
â€¢ Elements that can be compared (ordered)
â€¢ Ways to combine elements (join, meet)
â€¢ Consistent behavior under combination
â€¦you likely have a lattice!
This structure appears in programming languages, databases, security systems, logic circuits, and
many other areas of computer science and mathematics.
138 / 246
Properties of Lattices
Definition 63: A lattice is bounded if it has a greatest element âŠ¤ and a least element âŠ¥.
Example:
â€¢ âŸ¨ğ’«ï¸€(ğ´), âŠ†âŸ©: bounded with âŠ¤ = ğ´, âŠ¥ = âˆ…
â€¢ âŸ¨â„•+
, âˆ£âŸ©: bounded below (âŠ¥ = 1) but not above (no element divisible by all)
â€¢ âŸ¨â„¤, â‰¤âŸ©: not bounded (no maximum or minimum)
139 / 246
Distributive Lattices
Definition 64: A lattice is distributive if it satisfies the distributive laws:
ğ‘¥ âˆ§ (ğ‘¦ âˆ¨ ğ‘§) = (ğ‘¥ âˆ§ ğ‘¦) âˆ¨ (ğ‘¥ âˆ§ ğ‘§)
ğ‘¥ âˆ¨ (ğ‘¦ âˆ§ ğ‘§) = (ğ‘¥ âˆ¨ ğ‘¦) âˆ§ (ğ‘¥ âˆ¨ ğ‘§)
Note: In a lattice, one law implies the other.
Example: ğµ1 is distributive
Check:
â€¢ 0 âˆ§ (0 âˆ¨ 1) = 0 âˆ§ 1 = 0
â€¢ (0 âˆ§ 0) âˆ¨ (0 âˆ§ 1) = 0 âˆ¨ 0 = 0
â€¢ 0 = 0 âœ“
â€¢ Similarly for dual law
All Boolean algebras are distributive.
1
0
140 / 246
1
Non-Distributive Lattices
Example: ğ‘€3 is not distributive
Check:
â€¢ ğ‘ âˆ§ (ğ‘ âˆ¨ ğ‘) = ğ‘ âˆ§ 1 = ğ‘
â€¢ (ğ‘ âˆ§ ğ‘) âˆ¨ (ğ‘ âˆ§ ğ‘) = 0 âˆ¨ 0 = 0
â€¢ ğ‘ â‰  0 âœ—
ğ‘ ğ‘ ğ‘
The diamond ğ‘€3 is the forbidden sublattice for distributivity.
A lattice is distributive if and only if it does not have a sublattice isomorphic to ğ‘€3 or ğ‘5.
0
141 / 246
Distributive Lattices: Applications
Example: In compiler optimization, interprocedural dataflow analysis uses distributive lattices:
â€¢ Elements: Sets of dataflow facts (e.g., â€œvariable ğ‘¥ is constantâ€, â€œpointer ğ‘ may be nullâ€)
â€¢ Order: ğ‘†1 â‰¤ ğ‘†2 if ğ‘†1 âŠ† ğ‘†2 (subset of facts)
â€¢ Join: ğ‘†1 âˆ¨ ğ‘†2 = ğ‘†1 âˆª ğ‘†2 (merge facts from different paths)
â€¢ Meet: ğ‘†1 âˆ§ ğ‘†2 = ğ‘†1 âˆ© ğ‘†2 (common facts)
Why distributivity matters?
â€¢ Distributivity ensures that ğ‘“(ğ‘¥ âˆ¨ ğ‘¦) = ğ‘“(ğ‘¥) âˆ¨ ğ‘“(ğ‘¦) for flow functions ğ‘“.
â€¢ This allows separate analysis of different execution paths with guaranteed precision when merged.
â€¢ IFDS (Interprocedural, Finite, Distributive, Subset) problems (e.g., reachability, taint analysis) are
solvable in polynomial time precisely because the lattice is distributive!
142 / 246
Modular Lattices
Definition 65: A lattice is modular if for all ğ‘¥, ğ‘¦, ğ‘§ with ğ‘¥ â‰¤ ğ‘§:
ğ‘¥ âˆ¨ (ğ‘¦ âˆ§ ğ‘§) = (ğ‘¥ âˆ¨ ğ‘¦) âˆ§ ğ‘§
Note: Every distributive lattice is modular, but not vice versa.
Example: Diamond lattice ğ‘€3 is modular.
For ğ‘ â‰¤ 1:
â€¢ ğ‘ âˆ¨ (ğ‘ âˆ§ 1) = ğ‘ âˆ¨ ğ‘ = 1
â€¢ (ğ‘ âˆ¨ ğ‘) âˆ§ 1 = 1 âˆ§ 1 = 1
â€¢ 1 = 1 âœ“
Note: ğ‘€3 is modular but NOT distributive!
1
ğ‘ ğ‘ ğ‘
0
143 / 246
Non-Modular Lattices
Example: Pentagon lattice ğ‘5 is not modular.
For ğ‘ â‰¤ ğ‘:
â€¢ ğ‘ âˆ¨ (ğ‘ âˆ§ ğ‘) = ğ‘ âˆ¨ 0 = ğ‘
â€¢ (ğ‘ âˆ¨ ğ‘) âˆ§ ğ‘ = 1 âˆ§ ğ‘ = ğ‘
â€¢ ğ‘ â‰  ğ‘ âœ—
ğ‘
The pentagon ğ‘5 is the forbidden sublattice for modularity.
1
0
A lattice is modular if and only if it does not have a sublattice isomorphic to ğ‘5.
ğ‘
ğ‘
144 / 246
Modular Lattices: Applications
Hierarchy: Lattice â‡’ Modular â‡’ Distributive
Each level adds structure and enables different applications.
Example: The subspaces of a vector space ğ‘‰ , ordered by inclusion, form a modular lattice.
â€¢ Elements: subspaces ğ‘ˆ, ğ‘Š, ğ‘ âŠ† ğ‘‰
â€¢ Join: ğ‘ˆ âˆ¨ ğ‘Š = ğ‘ˆ + ğ‘Š (sum / span of ğ‘ˆ âˆª ğ‘Š)
â€¢ Meet: ğ‘ˆ âˆ§ ğ‘Š = ğ‘ˆ âˆ© ğ‘Š
For any two subspaces ğ‘ˆ, ğ‘Š of ğ‘‰ , we have the dimension formula:
dim(ğ‘ˆ + ğ‘Š) = dim(ğ‘ˆ) + dim(ğ‘Š) âˆ’ dim(ğ‘ˆ âˆ© ğ‘Š)
This expresses how dimensions â€œadd upâ€ when combining subspaces.
This is exactly the modular law in disguise!
The modular law governs how join (+) and meet (âˆ©) interact when one subspace is contained in another.
145 / 246
Modular Lattices: Applications [2]
Modular law: Whenever ğ‘ˆ âŠ† ğ‘, we have: ğ‘ˆ âˆ¨ (ğ‘Š âˆ§ ğ‘) = (ğ‘ˆ âˆ¨ ğ‘Š) âˆ§ ğ‘
Proof: We show both inclusions of the equality: ğ‘ˆ + (ğ‘Š âˆ© ğ‘) = (ğ‘ˆ + ğ‘Š) âˆ© ğ‘
Step 1 (âŠ†):
â€¢ Suppose ğ‘¥ âˆˆ ğ‘ˆ + (ğ‘Š âˆ© ğ‘).
â€¢ Then ğ‘¥ = ğ‘¢ + ğ‘¤â€² for some ğ‘¢ âˆˆ ğ‘ˆ, ğ‘¤â€² âˆˆ ğ‘Š âˆ© ğ‘.
â€¢ Since ğ‘¢ âˆˆ ğ‘ˆ âŠ† ğ‘ and ğ‘¤â€² âˆˆ ğ‘, we have ğ‘¥ âˆˆ ğ‘.
â€¢ Also ğ‘¥ âˆˆ ğ‘ˆ + ğ‘Š, hence ğ‘¥ âˆˆ (ğ‘ˆ + ğ‘Š) âˆ© ğ‘.
Step 2 (âŠ‡):
â€¢ Suppose ğ‘¥ âˆˆ (ğ‘ˆ + ğ‘Š) âˆ© ğ‘.
â€¢ Then ğ‘¥ = ğ‘¢ + ğ‘¤ for some ğ‘¢ âˆˆ ğ‘ˆ, ğ‘¤ âˆˆ ğ‘Š, and ğ‘¥ âˆˆ ğ‘.
â€¢ Because ğ‘ˆ âŠ† ğ‘, we have ğ‘¢ âˆˆ ğ‘, so ğ‘¤ = ğ‘¥ âˆ’ ğ‘¢ âˆˆ ğ‘.
â€¢ Thus ğ‘¤ âˆˆ ğ‘Š âˆ© ğ‘, and therefore ğ‘¥ = ğ‘¢ + ğ‘¤ âˆˆ ğ‘ˆ + (ğ‘Š âˆ© ğ‘).
Combining both directions, we conclude: ğ‘ˆ + (ğ‘Š âˆ© ğ‘) = (ğ‘ˆ + ğ‘Š) âˆ© ğ‘. â–¡
Interpretation: â€œJoining ğ‘ˆ and ğ‘Š, then cutting by ğ‘â€ equals â€œcutting ğ‘Š by ğ‘, then joining with ğ‘ˆâ€.
146 / 246
Example: Divisibility Lattice
Positive integers form a lattice under divisibility relation: ğ‘ â‰¤ ğ‘ iff ğ‘ divides ğ‘.
â€¢ Join (LCM): 6 âˆ¨ 10 = lcm(6, 10) = 30
â€¢ Meet (GCD): 6 âˆ§ 10 = gcd(6, 10) = 2
â€¢ Bottom element: 1 (divides everything)
â€¢ No top element: No positive integer is divisible by all others
â€£ If we include 0: then 0 is the top (divisible by all!)
Applications:
â€¢ Number theory and cryptography (RSA key generation)
â€¢ Computer algebra systems (polynomial GCD algorithms)
â€¢ Scheduling problems (finding common time periods)
0
8 12 20â‹¯
4 6 10â‹¯
2 3 5â‹¯
1
Lattices arenâ€™t just abstract algebra â€” they appear everywhere in computer science and mathematics.
The join and meet operations capture fundamental patterns of combination and interaction.
147 / 246
Example: File System Permissions
Unix file permissions form a lattice under inclusion.
â€¢ Elements: Sets of permissions like {ğ‘Ÿ, ğ‘¤, ğ‘¥}, {ğ‘Ÿ, ğ‘¥}, {ğ‘¤}, etc.
â€¢ Order: ğ‘ƒ1 â‰¤ ğ‘ƒ2 if ğ‘ƒ1 âŠ† ğ‘ƒ2 (fewer permissions â‡’ more restrictive)
â€¢ Join: Union of permissions (less restrictive)
â€£ For example: {read} âˆ¨ {execute} = {read, execute}
â€¢ Meet: Intersection of permissions (more restrictive)
â€£ For example: {read, write} âˆ§ {write, execute} = {write}
7: rwx
6: rw- 5: r-x 3: -wx
4: r-- 2: -w- 1: --x
0: ---
148 / 246
Example: Partition Lattice
All partitions of a set ğ‘†, ordered by refinement, form a lattice.
{1, 2, 3}â€¢ Elements: Partitions like (12 | 3), (1 | 23), (1 | 2 | 3), etc.
â€¢ Order: ğœ‹1 â‰¤ ğœ‹2 if ğœ‹1 is a refinement of ğœ‹2 (smaller blocks)
â€¢ Join: Finest common coarsening
â€£ For example: (12 | 3) âˆ¨ (1 | 23) = (123)
â€¢ Meet: Coarsest common refinement
â€£ For example: (12 | 3) âˆ§ (1 | 23) = (1 | 2 | 3)
{1, 2}, {3} {1, 3}, {2} {1}, {2, 3}
{1}, {2}, {3}
149 / 246
Example: Type Systems as Lattices
In programming language theory, types form a lattice under the subtyping relation âŠ‘.
The subtyping relation ğœ1 âŠ‘ ğœ2 means â€œğœ1 is more specific than ğœ2â€ (values of type ğœ1 can be safely
used where type ğœ2 is expected).
Join and meet operations solve type inference problems of finding common supertypes and subtypes.
Consider a type system with numeric, boolean, and
collection types:
any
number bool collection
int float array map
Lattice operations:
Join (âˆ¨): most specific common supertype
â€¢ intâˆ¨ float= number
â€¢ intâˆ¨ bool= any
â€¢ arrayâˆ¨ map= collection
Meet (âˆ§): most general common subtype
â€¢ numberâˆ§ collection= âŠ¥ (bottom type)
â€¢ intâˆ§ number= int
150 / 246
Example: Type Systems as Lattices [2]
Example (Type inference in conditionals): The code snippet below shows how join operations automatically
compute types in conditional expressions:
let x = cond ? 42 : 3.14 let y = cond ? x : true // type: int âˆ¨ float = number`
// type: number âˆ¨ bool = any`
The join operation gives the least upper bound type.
Example (Generic function bounds): Bounds in generic functions constrain what types can be passed:
<T extends Number> void process(T x) // Java
def f[T <: Number](x: T) // Scala
The type checker verifies that ğ‘‡ âŠ‘ Number by checking lattice relationships.
Note: Lattice-based type systems enable gradual typing (mixing typed and untyped code) and
sophisticated type inference. Examples: TypeScript, Flow, Dart, Cython, mypy.
151 / 246
Complemented Lattices
Definition 66: A lattice is complemented if for every element ğ‘¥ there exists an element ğ‘¦ (called the
complement of ğ‘¥) such that:
ğ‘¥ âˆ¨ ğ‘¦ = âŠ¤
ğ‘¥ âˆ§ ğ‘¦ = âŠ¥
Note: Complements may not be unique in general!
152 / 246
Boolean Algebras
Definition 67: A Boolean algebra is a complemented distributive lattice (ğµ, âˆ¨, âˆ§,
â€¢ a set ğµ
â€¢ with two binary operations âˆ¨ (join) and âˆ§ (meet),
â€¢ a unary operation Â¬ (complement),
â€¢ and two distinguished elements âŠ¤ (top) and âŠ¥ (bottom).
Â¬
, âŠ¤, âŠ¥):
Note: The complement Â¬ğ‘¥ is unique for each ğ‘¥ in a Boolean algebras!
Example: ğµ1 = ğŸ = ({0, 1}, âˆ¨, âˆ§,
Â¬
, 1, 0) is the two-element Boolean algebra (0 = false, 1 = true).
Isomorphic to (same structure up to renaming):
ğ‘¥ ğ‘¦ ğ‘¥ âˆ¨ ğ‘¦ ğ‘¥ âˆ§ ğ‘¦ Â¬ğ‘¥
â€¢ Classical semantics: ({0, 1}, max, min, 1 âˆ’ ğ‘¥)
â€¢ Algebra on sets: (ğ’«ï¸€({â‹†}), âˆª, âˆ©, âˆ)
â€¢ GF(2) algebra: ({0, 1}, âŠ•, âˆ§, 1 âŠ• ğ‘¥)
0 0 0 1 1 0 1 1 0 0 1
1 0 1
1 0 0
1 1 0
153 / 246
Boolean Lattices as Boolean Algebras
Example: Boolean lattice ğµ3 = (ğ’«ï¸€({ğ‘, ğ‘, ğ‘}), âˆª, âˆ©, ğ‘‹) is a Boolean algebra.
Elements: Subsets of {ğ‘, ğ‘, ğ‘} ordered by inclusion (âŠ†)
Operations:
â€¢ Join: ğ´ âˆ¨ ğµ = ğ´ âˆª ğµ
â€¢ Meet: ğ´ âˆ§ ğµ = ğ´ âˆ© ğµ
â€¢ Complement: Â¬ğ´ = ğ´ = {ğ‘, ğ‘, ğ‘} âˆ– ğ´
â€¢ Top: {ğ‘, ğ‘, ğ‘}
â€¢ Bottom: âˆ…
Check: {ğ‘} âˆ¨ Â¬{ğ‘} = {ğ‘} âˆª {ğ‘, ğ‘} = {ğ‘, ğ‘, ğ‘} = âŠ¤ âœ“
{ğ‘, ğ‘, ğ‘}
{ğ‘, ğ‘} {ğ‘, ğ‘} {ğ‘, ğ‘}
{ğ‘} {ğ‘} {ğ‘}
âˆ…
Stoneâ€™s Representation Theorem: Every Boolean algebra is isomorphic to a Boolean algebra of sets.
154 / 246
Boolean Algebras: Applications
Digital Circuit Design
Boolean algebras model logic gates:
â€¢ Variables: Input signals (0/1, false/true)
â€¢ Join: OR gate (âˆ¨)
â€¢ Meet: AND gate (âˆ§)
â€¢ Complement: NOT gate (Â¬)
Applications: CPU design, memory circuits,
FPGA programming
Key insight: Boolean algebras unify:
â€¢ Set theory (powerset operations)
â€¢ Logic (propositional calculus)
â€¢ Circuits (digital hardware)
Propositional Logic
Boolean algebras formalize logical reasoning:
â€¢ Elements: Truth values or propositions
â€¢ Join: Logical OR (ğ‘ âˆ¨ ğ‘)
â€¢ Meet: Logical AND (ğ‘ âˆ§ ğ‘)
â€¢ Complement: Negation (Â¬ğ‘)
Connection to lattices:
â€¢ ğœ‘ â‰¤ ğœ“ means â€œğœ‘ implies ğœ“â€
â€¢ Disjunction is join (weaker formula)
â€¢ Conjunction is meet (stronger formula)
Applications: SAT solvers, theorem provers,
formal verification
155 / 246
Summary: Lattice Theory
Core definitions:
â€¢ Lattice: Poset where every pair has a unique join (sup) and meet (inf)
â€¢ Bounded lattice: Has top (âŠ¤) and bottom (âŠ¥) elements
â€¢ Distributive lattice: Satisfies ğ‘¥ âˆ§ (ğ‘¦ âˆ¨ ğ‘§) = (ğ‘¥ âˆ§ ğ‘¦) âˆ¨ (ğ‘¥ âˆ§ ğ‘§)
â€¢ Modular lattice: Each ğ‘¥ â‰¤ ğ‘§ satisfies ğ‘¥ âˆ¨ (ğ‘¦ âˆ§ ğ‘§) = (ğ‘¥ âˆ¨ ğ‘¦) âˆ§ ğ‘§
â€¢ Boolean algebra: Complemented distributive lattice with ğ‘¥ âˆ¨ Â¬ğ‘¥ = âŠ¤, ğ‘¥ âˆ§ Â¬ğ‘¥ = âŠ¥
Key properties:
â€¢ Distributive lattice âŸº no ğ‘€3 or ğ‘5 sublattice
â€¢ Modular lattice âŸº no ğ‘5 sublattice
â€¢ Stoneâ€™s theorem: Every Boolean algebra is isomorphic to some powerset ğ’«ï¸€(ğ‘†)
156 / 246
Hierarchy of Lattice Structures
Key Examples of Lattices:
â€¢ ğµğ‘›
= ğ’«ï¸€({ğ‘¥1, â€¦, ğ‘¥ğ‘›}): Boolean lattice
â€£ Boolean algebra of sets
â€£ Universal model (by Stoneâ€™s theorem)
â€¢ ğŸ = ğµ1: Two-element Boolean algebra
â€£ Distributive âœ“
â€£ Models: logic, circuits, sets
â€¢ ğ‘´ğŸ‘: Diamond lattice
â€£ Modular âœ“, but NOT distributive âœ—
â€£ Forbidden for distributivity
â€¢ ğ‘µğŸ“: Pentagon lattice
â€£ Lattice âœ“, but NOT modular âœ—
â€£ Forbidden for modularity
Boolean Algebra
Distributive
Modular
Bounded
Lattice
Semilattice
Poset
157 / 246
Summary: Applications of Lattices
Main applications:
â€¢ Program analysis: Dataflow analysis (IFDS framework), abstract interpretation
â€¢ Type systems: Subtyping, type inference, generic programming
â€¢ Digital circuits: Logic gate design, circuit optimization, BDDs
â€¢ Abstract algebra: Subspace lattices in linear algebra
â€¢ Logic: Propositional calculus, SAT solvers, theorem proving
Connection to next topics:
â€¢ Well Orders: Special total orders where every subset has a minimum
â€¢ Cardinality: Comparing sizes of infinite sets using bijections
â€¢ Boolean Algebra: Deep dive into axioms, laws, circuits, and applications
â€¢ Formal Logic: Lattices provide algebraic semantics for logical systems
158 / 246
Well Orders
â€œEvery set can be well-ordered.â€
â€” Ernst Zermelo (Axiom of Choice)
Well-Ordered Sets
Definition 68: A poset âŸ¨ğ‘€, â‰¤âŸ© is well-ordered if every non-empty subset ğ‘† âŠ† ğ‘€ has a least element.
Formally: âˆ€ğ‘† âŠ† ğ‘€. (ğ‘† â‰  âˆ…) â†’ (âˆƒğ‘š âˆˆ ğ‘†. âˆ€ğ‘¥ âˆˆ ğ‘†. ğ‘š â‰¤ ğ‘¥)
The key property: No matter how you pick elements from a well-ordered set, thereâ€™s always a â€œfirstâ€
one in any selected subset.
This is stronger than just having a minimum â€” well-ordering means you canâ€™t descend infinitely!
Note: A well-ordered set is automatically a total order (any two elements are comparable).
160 / 246
Examples: Well-Ordered vs Not
Example (The natural numbers): â„• = {0, 1, 2, 3, â€¦} with â‰¤ is well-ordered:
â€¢ {5, 17, 23, 100} has least element 5
â€¢ {2, 4, 6, 8, â€¦} has least element 2
â€¢ Even {ğ‘› âˆˆ â„• | ğ‘› â‰¥ 1000} has least element 1000
Why this matters: You can always find a â€œstarting pointâ€ in any subset!
Example (The integers): â„¤ with â‰¤ is NOT well-ordered:
â€¢ {âˆ’1,
âˆ’2,
âˆ’3, â€¦} has no minimum
â€¢ â„¤ itself has no least element
â€¢ Can descend forever: 0 > âˆ’1 > âˆ’2 > âˆ’3 > â€¦
The problem: Negative numbers allow infinite descent.
Intuition: Well-ordering prevents â€œfalling forever.â€ Every subset has a floor you canâ€™t go below.
161 / 246
Example: Ordinals
Example (Ordinal numbers): Ordinals extend natural numbers into the transfinite:
â€¢ ğœ” = all natural numbers: 0, 1, 2, 3, â€¦
â€¢ ğœ” + 1 = natural numbers plus one more element â€œat the endâ€
â€¢ ğœ” + 2 = ğœ” + 1 plus another element
â€¢ ğœ” â‹… 2 = two copies of ğœ” in sequence
â€¢ ğœ”2
, ğœ”3
, â€¦, ğœ”ğœ”
, â€¦
Each ordinal is well-ordered, and ordinals themselves are well-ordered!
Key insight: Ordinals provide a canonical way to label positions in well-ordered sets.
162 / 246
Example: String Orderings
Two common ways to order finite strings over an alphabet:
Definition 69 (Shortlex order): Compare by length first, then alphabetically:
ğœ€ â‰º a â‰º b â‰º â€¦ â‰º aa â‰º ab â‰º â€¦
Well-ordered: Every set has a shortest string, ties broken alphabetically.
Example: {cat, dog, ox, zebra} has minimum â€œoxâ€ (shortest).
Definition 70 (Dictionary order): Compare alphabetically only, ignoring length:
a â‰º aa â‰º aaa â‰º â€¦ â‰º b â‰º ba â‰º â€¦
NOT well-ordered: {b, ab, aab, aaab, â€¦} has no minimum!
Infinite descent: b â‰» ab â‰» aab â‰» â€¦ (because a < b alphabetically).
163 / 246
Well-Ordering Enables Induction
Theorem 11: Let âŸ¨ğ‘†, â‰¤âŸ© be a well-ordered set. For any property ğ‘ƒ, if
âˆ€ğ‘¥ âˆˆ ğ‘†. (âˆ€ğ‘¦ < ğ‘¥. ğ‘ƒ(ğ‘¦)) â†’ ğ‘ƒ(ğ‘¥)
then ğ‘ƒ(ğ‘¥) holds for all ğ‘¥ âˆˆ ğ‘†.
Proof: Assume the hypothesis holds but ğ‘ƒ fails for some elements.
Let ğ‘‡ = {ğ‘¥ âˆˆ ğ‘† | Â¬ğ‘ƒ(ğ‘¥)} be the set of counterexamples.
Since ğ‘† is well-ordered, ğ‘‡ has a least element ğ‘š. This element ğ‘š is the smallest counterexample to ğ‘ƒ.
Then ğ‘ƒ(ğ‘˜) holds for all ğ‘˜ < ğ‘š (otherwise ğ‘š wouldnâ€™t be least).
By hypothesis, this implies ğ‘ƒ(ğ‘š) holds â€” contradicting ğ‘š âˆˆ ğ‘‡!
Therefore ğ‘‡ = âˆ…. â–¡
164 / 246
Two Forms of Induction on â„•
Definition 71 (Weak Induction): To prove âˆ€ğ‘› âˆˆ â„•. ğ‘ƒ(ğ‘›):
â€¢ Base: Prove ğ‘ƒ(0)
â€¢ Step: For any ğ‘›, prove ğ‘ƒ(ğ‘›) â†’ ğ‘ƒ(ğ‘› + 1)
Definition 72 (Strong Induction): To prove âˆ€ğ‘› âˆˆ â„•. ğ‘ƒ(ğ‘›):
â€¢ For any ğ‘›, assume ğ‘ƒ(ğ‘˜) for all ğ‘˜ < ğ‘›, then prove ğ‘ƒ(ğ‘›)
Note: These are equivalent for â„•. The difference is convenience:
â€¢ Weak: uses only ğ‘ƒ(ğ‘› âˆ’ 1) to prove ğ‘ƒ(ğ‘›)
â€¢ Strong: can use any ğ‘ƒ(ğ‘˜) with ğ‘˜ < ğ‘› to prove ğ‘ƒ(ğ‘›)
Example:
â€¢ Weak: Proving âˆ‘ğ‘›
ğ‘›(ğ‘›+1)
ğ‘–=0 ğ‘– =
2 (only need ğ‘ƒ(ğ‘›) for ğ‘ƒ(ğ‘› + 1))
â€¢ Strong: Proving Fibonacci formula (need ğ‘ƒ(ğ‘› âˆ’ 1) and ğ‘ƒ(ğ‘› âˆ’ 2) for ğ‘ƒ(ğ‘›))
165 / 246
Well-Ordering Principle
Definition 73 (Well-Ordering Principle (WOP)): Every non-empty subset of â„• has a least element.
Example:
â€¢ {5, 10, 15, 20, â€¦} has least element 5
â€¢ {ğ‘› âˆˆ â„• | ğ‘›2 > 100} has least element 11
â€¢ {ğ‘› âˆˆ â„• | ğ‘› is prime} has least element 2
Note: WOP is an axiom in Peano arithmetic, not provable from simpler principles.
Key: If a property fails, thereâ€™s a smallest counterexample â€” this makes proof by contradiction work.
166 / 246
WOP = Induction
Theorem 12: Well-Ordering Principle âŸº Mathematical Induction
Proof (WOP âŸ¹ Induction): Suppose WOP holds. To prove âˆ€ğ‘› âˆˆ â„•. ğ‘ƒ(ğ‘›), assume ğ‘ƒ fails.
Let ğ‘† = {ğ‘› âˆˆ â„• | Â¬ğ‘ƒ(ğ‘›)}. By WOP, ğ‘† has a least element ğ‘š.
Then ğ‘ƒ(ğ‘˜) holds for all ğ‘˜ < ğ‘š (since ğ‘š is least in ğ‘†).
By the induction hypothesis, ğ‘ƒ(ğ‘š) holds â€” contradicting ğ‘š âˆˆ ğ‘†! â–¡
Note: The reverse (Induction âŸ¹ WOP) can be proven similarly.
167 / 246
Well-Founded Relations
Well-ordering requires total comparability. Can we relax this?
Definition 74: A relation ğ‘… âŠ† ğ‘€2 is well-founded if every non-empty subset has a minimal element.
Formally: âˆ€ğ‘† âŠ† ğ‘€. (ğ‘† â‰  âˆ…) â†’ (âˆƒğ‘š âˆˆ ğ‘†. âˆ€ğ‘¥ âˆˆ ğ‘†. ğ‘¥ ğ‘… ğ‘š)
Note: Well-ordered â‰  Well-founded
â€¢ Well-ordered: unique least element (total order)
â€¢ Well-founded: one or more minimal elements (may be incomparable)
â€¢ Every well-ordered set is well-founded, but not vice versa.
Key insight: Both prevent infinite descent, but well-founded allows incomparable elements.
168 / 246
Example: Well-Founded but Not Well-Ordered
Example: Proper subset (âŠ‚) relation on ğ‘€ = {âˆ…, {ğ‘}, {ğ‘}, {ğ‘, ğ‘}}
Is it well-founded? âœ“
â€¢ Consider ğ‘† = {{ğ‘}, {ğ‘}, {ğ‘, ğ‘}}
â€¢ Minimal elements: {ğ‘} and {ğ‘} (nothing in ğ‘† is a proper subset of both)
â€¢ Note: {ğ‘, ğ‘} is not minimal
Is it well-ordered? âœ—
â€¢ {ğ‘} and {ğ‘} are incomparable
â€¢ No unique least element in ğ‘†
{ğ‘, ğ‘}
{ğ‘} {ğ‘}
âˆ…
Difference: Well-founded allows multiple incomparable minimals; well-ordered requires unique least.
169 / 246
Example: Divisibility Poset
Example: Consider âŸ¨â„•+
, |âŸ© with the divisibility relation.
Take the subset {4, 6, 8, 12, 18}:
Minimal elements: 4 and 6
â€¢ No divisors of 4 or 6 in this set
â€¢ Theyâ€™re incomparable: 4 âˆ¤ 6 and 6 âˆ¤ 4
Conclusion:
â€¢ Well-founded: every subset has minimals âœ“
â€¢ Well-ordered: no unique least âœ—
8 12 18
4 6
170 / 246
Example: Set Membership âˆˆ
Definition 75: In ZFC set theory, the Axiom of Regularity (also called Foundation) states:
âˆ€ğ‘† â‰  âˆ…. âˆƒğ‘¥ âˆˆ ğ‘†. (ğ‘¥ âˆ© ğ‘† = âˆ…)
Every non-empty set contains an element disjoint from itself.
Equivalently, every non-empty set has an âˆˆ-minimal element.
Examples:
â€¢ {âˆ…} has minimal âˆ…
â€¢ {{âˆ…}, {{âˆ…}}} has minimal {âˆ…}
â€¢ {{1}, {2}} has two minimals: {1} and {2}
â€¢ {1, 2, 3} has minimal 1 (since 1 âˆˆ 2 and 1 âˆˆ 3)
Key properties of âˆˆ:
â€¢ Well-founded? âœ“ (by Regularity)
â€¢ Well-ordered? âœ— (e.g. {1} âˆ‰ {2} and {2} âˆ‰ {1})
â€¢ No infinite descent (â€¦ âˆˆ ğ‘¥2 âˆˆ ğ‘¥1 âˆˆ ğ‘¥0)
â€¢ No self-membership (ğ‘¥ âˆˆ ğ‘¥)
â€¢ No cycles (ğ‘¥ âˆˆ ğ‘¦ âˆˆ ğ‘¥)
â€¢ âˆˆ-induction!
171 / 246
Example: Program Termination
def factorial(n):
if n == 0: return 1
return n * factorial(n-1)
Claim: factorial terminates for all ğ‘› âˆˆ â„•.
Proof:
â€¢ Recursive calls form a chain: ğ‘› â†’ (ğ‘› âˆ’ 1) â†’ (ğ‘› âˆ’ 2) â†’ â€¦ â†’ 1 â†’ 0
â€¢ This is a descending chain in âŸ¨â„•, <âŸ©
â€¢ Since âŸ¨â„•, <âŸ© is well-founded, no infinite descent
â€¢ Therefore, recursion terminates! â–¡
Application: Verification tools (Dafny, Coq, Agda, Lean) use well-founded relations to prove
termination of recursive functions.
172 / 246
Well-Founded Induction
Definition 76: Let âŸ¨ğ‘†, â‰ºâŸ© be well-founded. To prove âˆ€ğ‘¥ âˆˆ ğ‘†. ğ‘ƒ(ğ‘¥), show:
âˆ€ğ‘¥ âˆˆ ğ‘†. (âˆ€ğ‘¦ â‰º ğ‘¥. ğ‘ƒ(ğ‘¦)) â†’ ğ‘ƒ(ğ‘¥)
Key insight: Assume ğ‘ƒ(ğ‘¦) for all ğ‘¦ â€œsmallerâ€ than ğ‘¥, then prove ğ‘ƒ(ğ‘¥).
This generalizes strong induction â€” â€œsmallerâ€ is defined by â‰º instead of <.
Note: Also called: Noetherian induction, transfinite induction (on ordinals).
173 / 246
Proof of Well-Founded Induction
Proof: Assume the hypothesis but suppose ğ‘ƒ fails.
Let ğ‘†â€²
= {ğ‘¥ âˆˆ ğ‘† | Â¬ğ‘ƒ(ğ‘¥)}. Since âŸ¨ğ‘†, â‰ºâŸ© is well-founded, ğ‘†â€² has a minimal element ğ‘¥0.
For any ğ‘¦ â‰º ğ‘¥0: since ğ‘¥0 is minimal, ğ‘¦ âˆ‰ ğ‘†â€², so ğ‘ƒ(ğ‘¦) holds.
By hypothesis: (âˆ€ğ‘¦ â‰º ğ‘¥0. ğ‘ƒ(ğ‘¦)) â†’ ğ‘ƒ(ğ‘¥0).
So ğ‘ƒ(ğ‘¥0) holds â€” contradicting ğ‘¥0 âˆˆ ğ‘†â€²! â–¡
Pattern:
â€¢ Well-foundedness gives minimal counterexample
â€¢ â‡’ minimality makes hypothesis applicable
â€¢ â‡’ contradiction
174 / 246
Example: Termination via Well-Founded Induction
def process(S):
if S == âˆ…: return "done"
x = S.pop()
return process(S)
Claim: process(S) terminates for all finite ğ‘†.
Proof: Use well-founded induction on âŸ¨ğ’«ï¸€ fin, âŠ‚âŸ© (finite sets ordered by proper inclusion).
Assume process(T) terminates for all ğ‘‡ âŠ‚ ğ‘† (strictly smaller sets).
â€¢ If ğ‘† = âˆ…: returns immediately âœ“
â€¢ If ğ‘† â‰  âˆ…: recursive call uses ğ‘† âˆ– {ğ‘¥} âŠ‚ ğ‘†, which terminates by hypothesis âœ“
Therefore process(S) terminates for all finite ğ‘†. â–¡
Note: The relation âŠ‚ on finite sets is well-founded but not well-ordered (sets {1} and {2} are
incomparable).
175 / 246
Special Cases of Well-Founded Induction
Name Structure â€œSmallerâ€ means
Strong induction âŸ¨â„•, >âŸ© Numerically less
Transfinite induction Ordinals Earlier in order
Structural induction Trees, lists Proper substructure
Example (Structural induction on trees):
data Tree a = Empty | Node (Tree a) a (Tree a)
To prove ğ‘ƒ(tree) for all trees:
â€¢ Base: Prove ğ‘ƒ(Empty) (empty tree)
â€¢ Step: Assume ğ‘ƒ(ğ¿) and ğ‘ƒ(ğ‘…), prove ğ‘ƒ(Node(ğ¿, ğ‘£, ğ‘…))
The â€œsubtreeâ€ relation is well-founded.
176 / 246
Induced Strict Orders
To discuss chain conditions, we need strict orders derived from partial orders.
Definition 77 (Induced Strict Order): From any partial order â‰¤, we induce a strict order:
ğ‘¥ < ğ‘¦ iff ğ‘¥ â‰¤ ğ‘¦ and ğ‘¥ â‰  ğ‘¦
Similarly, ğ‘¥ > ğ‘¦ means ğ‘¦ < ğ‘¥ (the converse).
Convetion: For any poset âŸ¨ğ‘†, â‰¤âŸ©, we freely use < and > for induced strict orders.
This lets us express strictly ascending/descending sequences: ğ‘¥1 < ğ‘¥2 < ğ‘¥3 < â€¦
Example:
â€¢ In âŸ¨â„•, â‰¤âŸ©: 3 < 5 means 3 â‰¤ 5 and 3 â‰  5
â€¢ In âŸ¨ğ’«ï¸€(ğ‘€), âŠ†âŸ©: {ğ‘} < {ğ‘, ğ‘} means {ğ‘} âŠ† {ğ‘, ğ‘} and {ğ‘} â‰  {ğ‘, ğ‘}
177 / 246
Descending Chain Condition (DCC)
Definition 78: A poset âŸ¨ğ‘†, â‰¤âŸ© satisfies DCC if there are no infinite strictly descending chains:
ğ‘¥1 > ğ‘¥2 > ğ‘¥3 > ğ‘¥4 > â€¦
Example: âŸ¨â„•, â‰¤âŸ© satisfies DCC:
Any descending sequence eventually stabilizes at 0.
Intuition: â€œCanâ€™t fall foreverâ€ â€” every descent hits bottom or stabilizes.
178 / 246
Well-Founded âŸº DCC
Theorem 13: ğ‘… is well-founded âŸº ğ‘… satisfies DCC
Proof (Well-founded âŸ¹ DCC): Suppose infinite descending chain ğ‘¥0 > ğ‘¥1 > ğ‘¥2 > â€¦ exists.
Let ğ‘‡ = {ğ‘¥0, ğ‘¥1, ğ‘¥2, â€¦}. By well-foundedness, ğ‘‡ has minimal ğ‘¥ğ‘˜.
But ğ‘¥ğ‘˜ > ğ‘¥ğ‘˜+1 contradicts minimality! â–¡
Proof (DCC âŸ¹ Well-founded): Let ğ‘‡ âŠ† ğ‘† be non-empty. Pick ğ‘¥0 âˆˆ ğ‘‡.
If ğ‘¥0 is not minimal, pick ğ‘¥1 âˆˆ ğ‘‡ with ğ‘¥1 < ğ‘¥0. Repeat.
If this continues forever, we get infinite descent ğ‘¥0 > ğ‘¥1 > ğ‘¥2 > â€¦, contradicting DCC. â–¡
179 / 246
Ascending Chain Condition (ACC)
Definition 79: A poset satisfies ACC if no infinite strictly ascending chains exist:
ğ‘¥1 < ğ‘¥2 < ğ‘¥3 < ğ‘¥4 < â€¦
Example:
â€¢ âŸ¨â„•, â‰¤âŸ© does NOT satisfy ACC: 0 < 1 < 2 < 3 < â€¦
â€¢ âŸ¨ğ’«ï¸€(â„•), âŠ†âŸ© satisfies neither ACC nor DCC:
â€£ ACC fails: âˆ… âŠ‚ {1} âŠ‚ {1, 2} âŠ‚ â€¦
â€£ DCC fails: â„• âŠƒ â„• âˆ– {1} âŠƒ â„• âˆ– {1, 2} âŠƒ â€¦
Intuition: â€œCanâ€™t climb foreverâ€ â€” every ascent hits ceiling or stabilizes.
180 / 246
Noetherian Relations
Definition 80: ğ‘… is Noetherian if ğ‘…âˆ’1 is well-founded.
Equivalently: every non-empty subset has a maximal element.
Theorem 14: Noetherian âŸº ACC
Proof: Chain of equivalences:
ğ‘… is Noetherian âŸº ğ‘…âˆ’1 is well-founded
âŸº ğ‘…âˆ’1 satisfies DCC
âŸº ğ‘… satisfies ACC
â–¡
Duality: Well-founded has minimals + DCC; Noetherian has maximals + ACC.
181 / 246
Summary: Equivalences
Concept Definition Equivalent
Well-ordered Unique least in every subset Total + Well-founded
Well-founded Minimal(s) in every subset DCC
Noetherian Maximal(s) in every subset ACC
Key:
â€¢ Well-ordered â†’ well-founded
â€¢ Well-founded âŸº DCC
â€¢ Noetherian âŸº ACC
â€¢ Well-founded and Noetherian are duals
182 / 246
Application: Noetherian Rings
Definition 81: A ring is Noetherian if every ascending chain of ideals stabilizes:
ğ¼1 âŠ† ğ¼2 âŠ† ğ¼3 âŠ† â€¦
Example (â„¤ is Noetherian): Ideals in â„¤ have form ğ‘›â„¤ = {ğ‘›ğ‘˜ | ğ‘˜ âˆˆ â„¤} for ğ‘› âˆˆ â„•.
For chain ğ‘›1â„¤ âŠ† ğ‘›2â„¤ âŠ† â€¦:
â€¢ Inclusion means ğ‘›2 | ğ‘›1, so ğ‘›1 â‰¥ ğ‘›2 â‰¥ â€¦ in â„•
â€¢ By DCC, this sequence stabilizes
â€¢ Therefore the ideal chain stabilizes
183 / 246
Chain Conditions: Key Examples
Poset DCC? ACC?
âŸ¨â„•, â‰¤âŸ© âœ“ âœ—
âŸ¨â„¤âˆ’
, â‰¤âŸ© (negative integers) âœ— âœ“
âŸ¨ğ’«ï¸€({1, 2, 3}), âŠ†âŸ© (finite) âœ“ âœ“
âŸ¨ğ’«ï¸€(â„•), âŠ†âŸ© (infinite) âœ— âœ—
Key observation: DCC and ACC are independent â€” a structure can satisfy one, both, or neither!
184 / 246
Applications: From Theory to Practice
These abstract concepts â€” well-orders, well-founded relations, and chain conditions â€” are powerful tools
for proving termination, reasoning about infinity, and establishing finiteness properties.
The unifying principle: All capture variants of â€œno infinite regressâ€ â€” essential for proving processes
terminate and structures are well-behaved.
Examples (Computer science):
â€¢ Model checking: Well-founded relations guarantee finite state-space exploration
â€¢ Database systems: Datalog uses well-founded semantics for recursive queries
â€¢ Compiler optimization: Prove termination of optimization passes via well-founded metrics
â€¢ Graph algorithms: DFS/BFS termination follows from well-founded visit ordering
185 / 246
Applications: From Theory to Practice [2]
Examples (Mathematics & logic):
â€¢ Transfinite induction: Well-ordering enables proofs about infinite ordinals
â€¢ Set theory: Von Neumann ordinals constructed as well-ordered sets
â€¢ Rewriting systems: Confluence and termination via Noetherian orderings (Knuth-Bendix)
â€¢ Combinatorics: Dicksonâ€™s lemma uses well-quasi-orders for finiteness results
Examples (Software engineering):
â€¢ Scheduling algorithms: Priority queues maintain well-founded task ordering
â€¢ Garbage collection: Reachability analysis uses well-founded heap traversal
â€¢ Distributed systems: Lamport clocks establish well-founded event causality
â€¢ Version control: Commit DAGs form well-founded partial orders
186 / 246
Summary: Well-Founded Relations and Chain Conditions
Concept Definition Equivalent to
Well-ordered Every subset has unique least element Total + well-founded
Well-founded Every subset has minimal elements DCC
Noetherian Every subset has maximal elements ACC
DCC (Artinian) No infinite descending chains Well-founded
ACC (Noetherian) No infinite ascending chains Noetherian
Key relationships:
â€¢ Well-ordered â†’ well-founded (least â†’ minimal)
â€¢ Well-ordered â†’ total order (least elements force comparability)
â€¢ Well-founded âŸº DCC (equivalent characterizations)
â€¢ Noetherian âŸº ACC (equivalent characterizations)
187 / 246
Cardinality & Infinity
â€œGod made the integers, all else is the work of man.â€
â€” Leopold Kronecker
Giuseppe
Peano
Leopold
Kronecker
David Hilbert Kurt GÃ¶del John von
Neumann
Paul Cohen
Cardinality of Sets
Definition 82: The cardinality of a set ğ‘‹, denoted |ğ‘‹|, is a measure of its â€œsizeâ€.
â€¢ For finite sets, cardinality equals the number of elements: |{ğ‘, ğ‘, ğ‘}| = 3.
â€¢ For infinite sets, cardinality describes the â€œtypeâ€ of infinity, distinguishing between countable (like â„•)
and uncountable (like â„) infinities.
Key insight: Not all infinities are equal!
Some infinite sets are â€œlargerâ€ than others in a precise mathematical sense.
Example:
â€¢ |â„•| = â„µ0 (â€œaleph-nullâ€ â€” the smallest infinite cardinal, denoting countable infinity)
â€¢ |â„¤| = â„µ0 (surprisingly, same size as â„•!)
â€¢ |â„š| = â„µ0 (rationals are also countably infinite)
â€¢ |â„| = 2â„µ0 = ğ”  (â€œcontinuumâ€ â€” uncountably infinite)
â€¢ |ğ’«ï¸€(â„•)| = 2â„µ0 > â„µ0 (power set is always larger than the original set)
189 / 246
Cardinal Numbers
Note: |ğ‘‹| is not just a number, but a cardinal number.
â€¢ Cardinal numbers extend natural numbers to describe sizes of infinite sets
â€¢ The finite cardinals are: 0, 1, 2, 3, â€¦
â€¢ The first infinite cardinal is â„µ0 = |â„•|
â€¢ Arithmetic on infinite cardinals behaves differently: â„µ0 + 1 = â„µ0 and â„µ0â‹… 2 = â„µ0
Cantorâ€™s revolutionary insight (1874): We can compare sizes of infinite sets using bijections, just as
we compare finite sets by counting!
190 / 246
Equinumerosity
Definition 83: Two sets ğ´ and ğµ have the same cardinality and are called equinumerous, denoted
|ğ´| = |ğµ| or ğ´ â‰ˆ ğµ, iff there exists a bijection (one-to-one correspondence) between ğ´ and ğµ.
Intuition: If you can pair up every element of ğ´ with exactly one element of ğµ, with nothing left over on
either side, then ğ´ and ğµ have the same cardinality.
Theorem 15: Equinumerosity is an equivalence relation.
Proof: Let ğ´, ğµ, ğ¶ be sets.
â€¢ Reflexivity: The identity map idğ´ : ğ´ â†’ ğ´, where idğ´(ğ‘¥) = ğ‘¥, is a bijection, so ğ´ â‰ˆ ğ´.
â€¢ Symmetry: Suppose ğ´ â‰ˆ ğµ, then there is a bijection ğ‘“ : ğ´ â†’ ğµ. Since it is a bijection, its inverse ğ‘“âˆ’1
exists and is also a bijection. Hence, ğ‘“âˆ’1 : ğµ â†’ ğ´ is a bijection, so ğµ â‰ˆ ğ´.
â€¢ Transitivity: Suppose that ğ´ â‰ˆ ğµ and ğµ â‰ˆ ğ¶, i.e., there are bijections ğ‘“ : ğ´ â†’ ğµ and ğ‘” : ğµ â†’ ğ¶.
Then the composition ğ‘” âˆ˜ ğ‘“ : ğ´ â†’ ğ¶ is also a bijection. So ğ´ â‰ˆ ğ¶.
Therefore, equinumerosity is an equivalence relation. â–¡
191 / 246
Hilbertâ€™s Grand Hotel
Imagine a hotel with infinitely many rooms, numbered 1, 2, 3, â€¦, and all rooms are occupied.
A new guest arrives. Can we accommodate them? YES!
The solution: Move each guest in room ğ‘› to room ğ‘› + 1.
â€¢ Guest in room 1 moves to room 2
â€¢ Guest in room 2 moves to room 3
â€¢ And so onâ€¦
Now room 1 is vacant for the new guest!
Formally: Define the shift map ğ‘“ : â„• â†’ â„• by ğ‘“(ğ‘›) = ğ‘› + 1
â€¢ Injective: Different rooms map (shift) to different rooms
â€¢ Not surjective: Room 1 has no pre-image
The hotel can accommodate one more guest even though it is â€œfullâ€!
192 / 246
Dedekind-Infinite Sets
Definition 84: A set ğ‘‹ is Dedekind-infinite if some proper subset ğ‘Œ âŠ‚ ğ‘‹ is equinumerous to it, i.e.,
there is a bijection between ğ‘‹ and one of its proper subsets.
Equivalently, ğ‘‹ is Dedekind-infinite if there exists an injective but not surjective function ğ‘“ : ğ‘‹ â†’ ğ‘‹.
A set that is not Dedekind-infinite is called Dedekind-finite.
Note: Intuitively, an â€œinfiniteâ€ set can be put in one-to-one correspondence with a part of itself, which is
impossible for finite sets.
Example: The set of natural numbers â„• is Dedekind-infinite:
â€¢ Let ğ‘Œ = {2, 4, 6, 8, â€¦} = â„•even âŠ‚ â„• (proper subset)
â€¢ Define ğ‘“ : â„• â†’ ğ‘Œ by ğ‘“(ğ‘›) = 2ğ‘› (bijection)
â€¢ Since â„• â‰ˆ â„•even (equinumerous, bijection exists), the set â„• is Dedekind-infinite
193 / 246
Examples of Dedekind-Infinite Sets
Example: Integers â„¤ are Dedekind-infinite:
â€¢ Define ğ‘“ : â„¤ â†’ â„¤even by ğ‘“(ğ‘›) = 2ğ‘›
â€¢ This is a bijection: â„¤ â‰ˆ â„¤even âŠ‚ â„¤
Example: Rationals â„š are Dedekind-infinite:
â€¢ Define ğ‘“ : â„š â†’ â„š âˆ– [0; 1) by ğ‘“(ğ‘¥) = {ğ‘¥ ğ‘¥+1 if ğ‘¥â‰¥0
if ğ‘¥<0
â€¢ This â€œskipsâ€ the interval [0; 1), giving a bijection onto â„š âˆ– [0, 1) âŠ‚ â„š
Example: Real numbers (0; 1) are Dedekind-infinite:
â€¢ Define ğ‘“ : (0; 1) â†’ (0; 1
2) by ğ‘“(ğ‘¥) =
ğ‘¥
2
â€¢ This is a bijection: (0; 1) â‰ˆ (0; 1
2) âŠ‚ (0; 1)
Key insight: Being Dedekind-infinite is equivalent to being infinite (assuming the Axiom of Choice).
This gives us a purely set-theoretic definition of infinity without counting!
194 / 246
Hilbertâ€™s Hotel: Infinitely Many New Guests
The Greater Challenge: Now a bus with infinitely many passengers arrives (numbered 1, 2, 3, â€¦).
The hotel is still completely full. Can we accommodate all of them? The solution:
Ask each current guest in room ğ‘› to move to room 2ğ‘›:
ğ‘“current : â„• â†’ â„•even, ğ‘“current(ğ‘›) = 2ğ‘›
This creates infinitely many vacant odd-numbered rooms: {1, 3, 5, 7, 9, â€¦}
Then, assign bus passenger ğ‘˜ to room 2ğ‘˜ âˆ’ 1:
ğ‘“new : â„• â†’ â„•odd, ğ‘“new(ğ‘˜) = 2ğ‘˜ âˆ’ 1
YES!
195 / 246
Hilbertâ€™s Hotel: Infinitely Many New Guests [2]
Original Current Guest âŸ¶ New Room New Guest
Room 1 Guest #1 Room 2
Room 2 Guest #2 Room 4
Room 3 Guest #3 Room 6
â‹® â‹® â‹®
Room 1 Bus passenger #1
Room 3 Bus passenger #2
Room 5 Bus passenger #3
â‹® â‹®
This demonstrates that â„• (all guests) is equinumerous to â„•even (current guests) and â„•odd (new guests):
|â„•| = |â„•even| = |â„•odd| = â„µ0
Moreover, we showed that â„• â‰ˆ â„•even âŠ” â„•odd, illustrating that â„µ0 + â„µ0 = â„µ0.
196 / 246
Countable Sets
Definition 85: A set is countable if it is either finite, or has the same cardinality as â„• (i.e., there exists
a bijection with â„•).
An infinite countable set has cardinality â„µ0.
Key insight: A countable set is one whose elements can be â€œlistedâ€ in a sequence ğ‘0, ğ‘1, ğ‘2, â€¦,
pairing each with a natural number.
Example: Integers â„¤ = {â€¦,
âˆ’2,
âˆ’1, 0, 1, 2, â€¦} are countable: |â„¤| = â„µ0
Bijection ğ‘“ : â„• â†’ â„¤:
ğ‘“(ğ‘›) = {ğ‘›
2 if ğ‘› is even
ğ‘›+1
âˆ’
2 if ğ‘› is odd [â„•:
â„¤:
0
1
2
3
0
âˆ’1
1
âˆ’2
This systematically pairs each natural number with exactly one integer.
4
2
5
âˆ’3
6
3
7
âˆ’4
â€¦
â€¦]
197 / 246
Properties of Countable Sets
Theorem 16:
1. 2. 3. 4. Any subset of a countable set is countable
The union of countably many countable sets is countable
The Cartesian product of two countable sets is countable
The set of finite sequences over a countable alphabet is countable
198 / 246
Examples of Countable Sets
Example: Finite binary strings Î£âˆ—
= {ğœ€, 0, 1, 00, 01, 10, 11, 000, â€¦} over Î£ = {0, 1}:
â€¢ List by length, then lexicographically: ğœ€ (length 0), then 0, 1 (length 1), then 00, 01, 10, 11 (length 2), etc.
â€¢ Since each length class is finite and there are countably many lengths, Î£âˆ— is countable
Example: Polynomials with integer coefficients â„¤[ğ‘¥]:
â€¢ Group by degree and coefficient sum, enumerate systematically
â€¢ Countable because expressible as finite sequences over â„¤
Example: Algebraic numbers (roots of polynomials with integer coefficients):
â€¢ Each polynomial has finitely many roots
â€¢ â€œCountably many polynomialsâ€ Ã— â€œfinitely many roots eachâ€ = countable
199 / 246
Zig-Zag Enumeration: â„•2 is Countable
Theorem 17: â„• Ã— â„• is countable.
Proof: We enumerate pairs by diagonals of constant sum ğ‘  = ğ‘› + ğ‘˜ for ğ‘  = 0, 1, 2, â€¦
ğ‘› â†“ ğ‘˜ â†’ 0 1 2 3 â€¦
0 âŸ¨0, 0âŸ©
0
1 âŸ¨1, 0âŸ©
1
2 âŸ¨2, 0âŸ©
3
3 âŸ¨3, 0âŸ©
6
âŸ¨0, 1âŸ©
2
âŸ¨1, 1âŸ©
4
âŸ¨2, 1âŸ©
7
âŸ¨3, 1âŸ©
11
âŸ¨0, 2âŸ©
5
âŸ¨1, 2âŸ©
8
âŸ¨2, 2âŸ©
12
âŸ¨3, 2âŸ©
17
âŸ¨0, 3âŸ©
9â€¦
âŸ¨1, 3âŸ©
13â€¦
âŸ¨2, 3âŸ©
18â€¦
âŸ¨3, 3âŸ©
24â€¦
â‹® â‹® â‹® â‹® â‹® â‹±
200 / 246
Zig-Zag Enumeration: â„•2 is Countable [2]
The Cantor pairing function gives an explicit bijection ğ‘“ : â„•2 â†’ â„•:
(ğ‘› + ğ‘˜)(ğ‘› + ğ‘˜ + 1)
ğ‘“(ğ‘›, ğ‘˜) =
+ ğ‘˜
2
âŸ
pairs before diagonal ğ‘›+ğ‘˜
âŸ
position within diagonal
Therefore â„•2 â‰ˆ â„•, so |â„•2| = â„µ0. â–¡
Why this matters: â€œ2-dimensional infinityâ€ is the same size as â€œ1-dimensional infinityâ€!
More generally, â„•ğ‘› is countable for any finite ğ‘›.
201 / 246
Rationals are Countable
Theorem 18: â„š is countable.
Proof: We construct an injection from â„š into â„• Ã— â„•, which is countable.
Step 1: Map each positive rational ğ‘
ğ‘ (as a reduced fraction) to (ğ‘, ğ‘) âˆˆ â„• Ã— â„•.
â€¢ This is injective: different reduced fractions have different (ğ‘, ğ‘) pairs
â€¢ Since â„• Ã— â„• is countable, â„š+ âª¯ â„• Ã— â„• (injection) implies â„š+ is countable
Step 2: Decompose â„š = â„š+ âˆª {0} âˆª â„šâˆ’ (union of three disjoint sets).
â€¢ â„š+ is countable (Step 1), {0} is finite, â„šâˆ’
â‰ˆ â„š+ via ğ‘“(ğ‘¥) = âˆ’ğ‘¥
Step 3: Union of three countable sets is countable, so â„š is countable. â–¡
Surprising fact: There are â€œas manyâ€ rationals as integers, even though rationals are dense (between
any two, thereâ€™s another) while integers are discrete!
202 / 246
Uncountable Sets: Cantorâ€™s Diagonal Argument
Definition 86: A set is uncountable if it is infinite but not countable (no bijection with â„• exists).
Cantorâ€™s strategy: Given any proposed â€œlistâ€ of all elements, construct a new element that differs
from each item in the list, proving the list is incomplete.
Theorem 19: The set ğ”¹ğœ” of all infinite binary sequences is uncountable.
Why ğ”¹ğœ”? Itâ€™s simpler than â„ but has the same cardinality: |ğ”¹ğœ”| = |â„| = 2â„µ0 = ğ” .
Binary sequences can represent real numbers via binary expansions!
Proof: Suppose for contradiction that ğ”¹ğœ” is countable. Then we can enumerate its elements as
ğ‘¥1, ğ‘¥2, ğ‘¥3, â€¦, where ğ‘¥ğ‘– = (ğ‘ğ‘–1, ğ‘ğ‘–2, ğ‘ğ‘–3, â€¦) is an infinite bit sequence.
203 / 246
Uncountable Sets: Cantorâ€™s Diagonal Argument [2]
We can represent this enumeration as an infinite table, where each row corresponds to a (supposedly
countable) sequence ğ‘¥ğ‘– and each column corresponds to a bit position (natural numbers):
Seq Bit 1 Bit 2 Bit 3 Bit 4 â€¦
ğ‘11 ğ‘12 ğ‘13 ğ‘14â€¦
ğ‘21 ğ‘22 ğ‘23 ğ‘24â€¦
ğ‘31 ğ‘32 ğ‘33 ğ‘34â€¦
ğ‘41 ğ‘42 ğ‘43 ğ‘44â€¦
â‹® â‹® â‹® â‹® â‹® â‹±
ğ‘¥1 ğ‘¥2 ğ‘¥3 ğ‘¥4 Î” ğ‘11 ğ‘22 ğ‘33 ğ‘44â€¦
Construct Î” = (ğ‘11, ğ‘22, ğ‘33, â€¦) by flipping each diagonal bit:
ğ‘ğ‘–ğ‘– = {1 if ğ‘ğ‘–ğ‘– = 0
0 if ğ‘ğ‘–ğ‘– = 1
204 / 246
Uncountable Sets: Cantorâ€™s Diagonal Argument [3]
Key observation: Î” â‰  ğ‘¥ğ‘– for any ğ‘–, because they differ at position ğ‘–: ğ‘ğ‘–ğ‘– â‰  ğ‘ğ‘–ğ‘–.
But Î” âˆˆ ğ”¹ğœ”, since it is an infinite binary sequence, so it should appear in our enumeration. Contradiction!
Therefore, ğ”¹ğœ” is uncountable. â–¡
Connection to zig-zag:
â€¢ Zig-zag (for â„•2): Each diagonal is finite, we can list all pairs
â€¢ Diagonal argument (for ğ”¹ğœ”): Sequences are infinite, impossible to list completely!
205 / 246
More Uncountable Sets
Example: Real numbers â„ are uncountable:
â€¢ Map each ğ‘¥ âˆˆ (0; 1) to its binary expansion sequence in ğ”¹ğœ”
â€¢ Since ğ”¹ğœ” is uncountable and (0, 1) â‰ˆ â„, we have |â„| = 2â„µ0 = ğ” 
Example: Power set ğ’«ï¸€(â„•) is uncountable:
â€¢ Map each ğ‘† âŠ† â„• to its characteristic sequence (ğœ’ğ‘†(0), ğœ’ğ‘†(1), ğœ’ğ‘†(2), â€¦) âˆˆ ğ”¹ğœ”
â€¢ This is a bijection: ğ’«ï¸€(â„•) â‰ˆ ğ”¹ğœ”
â€¢ Therefore |ğ’«ï¸€(â„•)| = 2â„µ0 (matches Cantorâ€™s theorem!)
206 / 246
More Uncountable Sets [2]
Example: Irrational numbers ğ•€ = â„ âˆ– â„š are uncountable:
â€¢ If ğ•€ were countable, then â„ = â„š âˆª ğ•€ would be a union of two countable sets, hence countable
â€¢ But â„ is uncountable, contradiction!
â€¢ Most real numbers are irrational (in a measure-theoretic sense)
Example (Computer science connections):
â€¢ Undecidable problems: There are uncountably many languages over any alphabet, but only countably
many algorithms (finite strings). Most languages have no decision algorithm!
â€¢ Real computation: Real numbers are uncountable, but computable reals are countable
â€¢ Cryptography: Security often relies on the vastness of uncountable key spaces
207 / 246
Comparing Cardinalities
Definition 87: The cardinality of ğ´ is less than or equal to that of ğµ, denoted |ğ´| â‰¤ |ğµ| or ğ´ âª¯ ğµ,
if there exists an injection ğ‘“ : ğ´ â†’ ğµ.
Definition 88: The cardinality of ğ´ is strictly less than that of ğµ, denoted |ğ´| < |ğµ| or ğ´ â‰º ğµ,
if ğ´ âª¯ ğµ and ğ´ â‰‰ ğµ (injection exists, but no bijection).
Key insight: Injections let us compare sizes without needing full bijections!
Example:
â€¢ |{1, 2}| < |{ğ‘, ğ‘, ğ‘}| because ğ‘“(1) = ğ‘, ğ‘“(2) = ğ‘ is injective, but no bijection exists
â€¢ |â„•| â‰¤ |â„¤| and |â„¤| â‰¤ |â„•| (both have bijections, so |â„•| = |â„¤|)
â€¢ |â„•| < |ğ’«ï¸€(â„•)| because ğ‘“(ğ‘›) = {ğ‘›} is injective, but Cantorâ€™s theorem says no bijection exists
â€¢ |â„•| < |â„| because ğ‘“ : â„• â†’ â„ via ğ‘“(ğ‘›) = ğ‘› is injective, but diagonal argument shows no bijection
208 / 246
Cantorâ€™s Theorem
Theorem 20 (Cantor): ğ´ â‰º ğ’«ï¸€(ğ´) for any set ğ´.
Proof: The map ğ‘“(ğ‘¥) = {ğ‘¥} is an injection from ğ´ to ğ’«ï¸€(ğ´), since if ğ‘¥ â‰  ğ‘¦, then {ğ‘¥} â‰  {ğ‘¦}, and so
ğ‘“(ğ‘¥) â‰  ğ‘“(ğ‘¦). So we have shown that ğ´ âª¯ ğ’«ï¸€(ğ´).
To show that ğ´ â‰‰ ğ’«ï¸€(ğ´), suppose for reductio that there is a bijection ğ‘” : ğ´ â†’ ğ’«ï¸€(ğ´).
â€¢ Consider ğ· = {ğ‘¥ âˆˆ ğ´ | ğ‘¥ âˆ‰ ğ‘”(ğ‘¥)}. Note that ğ· âŠ† ğ´, so ğ· âˆˆ ğ’«ï¸€(ğ´).
â€¢ Since ğ‘” is surjective, there exists ğ‘¦ âˆˆ ğ´ such that ğ‘”(ğ‘¦) = ğ·.
â€£ If ğ‘¦ âˆˆ ğ·, then by definition of ğ·, we have ğ‘¦ âˆ‰ ğ‘”(ğ‘¦), i.e., ğ‘¦ âˆ‰ ğ·. Contradiction!
â€£ If ğ‘¦ âˆ‰ ğ·, then ğ‘¦ âˆ‰ ğ‘”(ğ‘¦), so by definition of ğ·, we have ğ‘¦ âˆˆ ğ·. Contradiction!
â€¢ Therefore, no bijection ğ´ â†’ ğ’«ï¸€(ğ´) can exist, so ğ´ â‰‰ ğ’«ï¸€(ğ´). â–¡
Profound implication: There is no â€œlargestâ€ infinity! We can always construct a bigger one using the
power set operation: â„µ0 < 2â„µ0 < 22â„µ0 < â€¦
209 / 246
SchrÃ¶derâ€“Bernstein Theorem
Theorem 21 (SchrÃ¶derâ€“Bernstein): If ğ´ âª¯ ğµ and ğµ âª¯ ğ´, then ğ´ â‰ˆ ğµ.
Equivalently: if injections ğ‘“ : ğ´ â†’ ğµ and ğ‘” : ğµ â†’ ğ´ both exist, then a bijection â„ : ğ´ â†’ ğµ exists.
What this means: If each set â€œfits insideâ€ the other, they have the same size!
This powerful result lets us prove equality of cardinalities without constructing explicit bijections.
Example: (0; 1) â‰ˆ [0; 1] (open interval equals closed interval):
â€¢ Injection ğ‘“ : (0; 1) â†’ [0; 1] by ğ‘“(ğ‘¥) = ğ‘¥ (identity)
â€¢ Injection ğ‘” : [0; 1] â†’ (0; 1) by ğ‘”(ğ‘¥) =
ğ‘¥
2 + 1
4 (shrink and shift to (1
4; 3
4))
â€¢ By SchrÃ¶derâ€“Bernstein, there exists a bijection between them!
Note: The proof is non-trivial and constructive. Weâ€™ll see it in a dedicated section later.
210 / 246
Unit Line vs. Unit Square
Theorem 22: The unit line ğ¿ = [0; 1] and unit square ğ‘† = [0; 1]2 are equinumerous.
ğ¿ â‰ˆ ğ‘† Surprise! A 1D object has the same cardinality as a 2D object!
Proof4: Step 1: Injection ğ‘“ : ğ¿ â†’ ğ‘† by ğ‘“(ğ‘¥) = âŸ¨ğ‘¥, ğ‘¥âŸ© gives ğ¿ âª¯ ğ‘†.
â€¢ If ğ‘“(ğ‘) = ğ‘“(ğ‘), then âŸ¨ğ‘, ğ‘âŸ© = âŸ¨ğ‘, ğ‘âŸ©, so ğ‘ = ğ‘
Step 2: Injection ğ‘” : ğ‘† â†’ ğ¿ by interleaving decimal digits gives ğ‘† âª¯ ğ¿:
ğ‘¥ = 0.ğ‘¥1ğ‘¥2ğ‘¥3â€¦
ğ‘¦ = 0.ğ‘¦1ğ‘¦2ğ‘¦3â€¦ } ğ‘”(ğ‘¥, ğ‘¦) = 0.ğ‘¥1ğ‘¦1ğ‘¥2ğ‘¦2ğ‘¥3ğ‘¦3â€¦
â€¢ If ğ‘”(ğ‘, ğ‘) = ğ‘”(ğ‘, ğ‘‘), then all digits match, so âŸ¨ğ‘, ğ‘âŸ© = âŸ¨ğ‘, ğ‘‘âŸ©
Step 3: By SchrÃ¶derâ€“Bernstein (Theorem 21), we conclude ğ¿ â‰ˆ ğ‘†. â–¡
4See https://math.stackexchange.com/a/183383 for more detailed analysis.
211 / 246
Summary: Cardinality & Infinity
Cardinality measures set â€œsize,â€ with surprising distinctions among infinities:
â€¢ Finite sets: Cardinality = element count
â€¢ Countable infinity (â„µ0): Sets like â„•, â„¤, â„š that can be listed (bijection with â„•)
â€¢ Uncountable infinity: Sets like â„ and ğ’«ï¸€(â„•) too large to enumerate (e.g., |â„| = 2â„µ0 = ğ” )
Key techniques:
â€¢ Equinumerosity: Sets have equal cardinality iff a bijection exists between them
â€¢ Injections: Prove |ğ´| â‰¤ |ğµ| by constructing a one-to-one map
â€¢ Diagonal argument: Prove uncountability by showing no enumeration can be complete
â€¢ SchrÃ¶derâ€“Bernstein: Two injections (both ways) yield a bijection
212 / 246
Summary: Cardinality & Infinity [2]
Mind-bending facts:
â€¢ |â„•| = |â„¤| = |â„š| = â„µ0 (integers and rationals are â€œsame sizeâ€ as naturals!)
â€¢ |â„• Ã— â„•| = |â„•| (2D grid has same size as 1D line)
â€¢ [0; 1] â‰ˆ [0; 1]2 (unit line equals unit square!)
â€¢ |â„•| < |ğ’«ï¸€(â„•)| < |ğ’«ï¸€(ğ’«ï¸€(â„•))| < â€¦ (infinitely many infinities!)
â€¢ Most real numbers are not algebraic (computable reals are countable, but all reals are uncountable)
213 / 246
Enumerations and Countability
Enumerable Sets
Definition 89: A set ğ‘‹ is enumerable if there exists a surjection ğ‘’ : â„• â†’ ğ‘‹.
The function ğ‘’ is called an enumeration of ğ‘‹.
Intuition: An enumerable set can be â€œlistedâ€ as ğ‘’(0), ğ‘’(1), ğ‘’(2), â€¦ (possibly with repetitions).
Note: Elements may appear multiple times since we only require a surjection, not a bijection.
Example: Even numbers: ğ‘’(ğ‘›) = 2ğ‘› gives 0, 2, 4, 6, 8, â€¦
Example: Perfect squares: ğ‘’(ğ‘›) = ğ‘›2 gives 0, 1, 4, 9, 16, 25, â€¦
Example: Prime numbers: ğ‘’(0) = 2, ğ‘’(1) = 3, ğ‘’(2) = 5, ğ‘’(3) = 7, â€¦ (via Sieve of Eratosthenes)
215 / 246
Three Equivalent Characterizations
Theorem 23: For any set ğ‘‹, the following are equivalent:
1. ğ‘‹ is countable: ğ‘‹ is finite or has a bijection with â„•
2. ğ‘‹ is enumerable: there exists a surjection ğ‘’ : â„• â†’ ğ‘‹
3. ğ‘‹ is embeddable in â„•: ğ‘‹ = âˆ… or there exists an injection ğ‘“ : ğ‘‹ â†’ â„•
Practical guide:
â€¢ Use bijection when you can construct an explicit 1-1 correspondence
â€¢ Use surjection (enumeration) when you can algorithmically list elements
â€¢ Use injection when ğ‘‹ embeds naturally into â„• (often easiest!)
216 / 246
Proof of Equivalence
Proof: We prove (1) â‡’ (2) â‡’ (3) â‡’ (1).
(1) â‡’ (2): Suppose ğ‘‹ is countable.
â€¢ If ğ‘‹ is finite: ğ‘‹ = {ğ‘¥0, â€¦, ğ‘¥ğ‘›âˆ’1}, define ğ‘’(ğ‘˜) = {ğ‘¥ğ‘˜ if ğ‘˜<ğ‘›
ğ‘¥0 if ğ‘˜â‰¥ğ‘› (surjection)
â€¢ If ğ‘‹ â‰ˆ â„•: any bijection ğ‘” : â„• â†’ ğ‘‹ is also a surjection
(2) â‡’ (3): Suppose ğ‘’ : â„• â†’ ğ‘‹ is a surjection.
â€¢ If ğ‘‹ = âˆ…, done
â€¢ Otherwise, for each ğ‘¥ âˆˆ ğ‘‹, define ğ‘“(ğ‘¥) = min{ğ‘› âˆˆ â„• | ğ‘’(ğ‘›) = ğ‘¥} (first occurrence)
â€¢ This is injective: if ğ‘“(ğ‘¥) = ğ‘“(ğ‘¦) = ğ‘›, then ğ‘’(ğ‘›) = ğ‘¥ and ğ‘’(ğ‘›) = ğ‘¦, so ğ‘¥ = ğ‘¦
(3) â‡’ (1): Suppose ğ‘‹ = âˆ… or ğ‘“ : ğ‘‹ â†’ â„• is injective.
â€¢ If ğ‘‹ = âˆ…, then ğ‘‹ is finite (countable)
â€¢ Otherwise, ğ‘‹ â‰ˆ ğ‘“(ğ‘‹) âŠ† â„•
â€¢ Since any subset of â„• is countable, ğ‘‹ is countable
â–¡
217 / 246
Infinite Subsets of â„•
Theorem 24: Any infinite subset ğ´ âŠ† â„• is equinumerous to â„•.
Proof: Construct a bijection ğ‘“ : â„• â†’ ğ´ recursively:
â€¢ ğ‘“(0) = min ğ´ (â„• is well-ordered â‡’ any ğ´ âŠ† â„• has a least element)
â€¢ ğ‘“(ğ‘› + 1) = min(ğ´ âˆ– {ğ‘“(0), ğ‘“(1), â€¦, ğ‘“(ğ‘›)})
Since ğ´ is infinite, ğ´ âˆ– {ğ‘“(0), â€¦, ğ‘“(ğ‘›)} is always non-empty and has a minimum.
Injective: By construction, all ğ‘“(ğ‘–) are distinct.
Surjective: Every ğ‘ âˆˆ ğ´ eventually becomes the minimum of a remaining set.
Therefore ğ‘“ is a bijection, so |ğ´| = â„µ0. â–¡
Key insight: Thereâ€™s only â€œone sizeâ€ of countably infinite set: â„µ0.
218 / 246
Enumeration Examples
Example (Finite strings over Î£ = {ğ‘, ğ‘}): Enumerate Î£âˆ— by length, then lexicographically:
ğœ€, ğ‘, ğ‘, ğ‘ğ‘, ğ‘ğ‘, ğ‘ğ‘, ğ‘ğ‘, ğ‘ğ‘ğ‘, ğ‘ğ‘ğ‘, â€¦
â€¢ Length 0: ğœ€ (1 string)
â€¢ Length 1: ğ‘, ğ‘ (2 strings)
â€¢ Length 2: ğ‘ğ‘, ğ‘ğ‘, ğ‘ğ‘, ğ‘ğ‘ (4 strings)
â€¢ Length ğ‘›: 2ğ‘› strings
Since â‹ƒâˆ
ğ‘›=0 2ğ‘› is a countable union of finite sets, Î£âˆ— is countable.
Example (Rational numbers): List positive fractions ğ‘
ğ‘ by increasing ğ‘ + ğ‘, skip non-reduced:
1
1
2
1
1
2
3
4
3
1,
2,
1,
3,
1,
4,
3,
2,
1, â€¦
Include 0 and negatives by interleaving:
1
1
1
1
2
2
0,
âˆ’
âˆ’
âˆ’
1,
1,
2,
2,
1,
1, â€¦
219 / 246
SchrÃ¶derâ€“Bernstein
Proof of SchrÃ¶derâ€“Bernstein Theorem
Theorem 25: If injections ğ‘“ : ğ´ â†’ ğµ and ğ‘” : ğµ â†’ ğ´ exist, then a bijection â„ : ğ´ â†’ ğµ exists.
Proof: Let ğ‘“ : ğ´ â†’ ğµ and ğ‘” : ğµ â†’ ğ´ be injections.
We use ğ‘”âˆ’1 to denote the inverse of ğ‘” restricted to its image: for any ğ‘ âˆˆ ğ‘”(ğµ), we write ğ‘”âˆ’1(ğ‘) for the
unique ğ‘ âˆˆ ğµ satisfying ğ‘”(ğ‘) = ğ‘.
Step 1: Construct auxiliary sets
Define inductively the sets ğ´ğ‘› âŠ† ğ´ and ğµğ‘› âŠ† ğµ for ğ‘› â‰¥ 0 by:
ğ´0 â‰” ğ´ âˆ– ğ‘”(ğµ)
ğµğ‘›
â‰” ğ‘“(ğ´ğ‘›) ğ´ğ‘›+1 â‰” ğ‘”(ğµğ‘›) for ğ‘› â‰¥ 0
for ğ‘› â‰¥ 0
Define ğ´âˆ âŠ† ğ´ as the union of all ğ´ğ‘›: ğ´âˆ
â‰” â‹ƒ
ğ‘›â‰¥0
ğ´ğ‘›.
221 / 246
Proof of SchrÃ¶derâ€“Bernstein Theorem [2]
Step 2: Define the candidate bijection
Define â„ : ğ´ â†’ ğµ by:
â„(ğ‘) = {ğ‘“(ğ‘) ğ‘”âˆ’1(ğ‘) if ğ‘ âˆ‰ ğ´âˆ
if ğ‘ âˆˆ ğ´âˆ
Step 3: Verify â„ is well-defined
For all ğ‘ âˆˆ ğ´, we need â„(ğ‘) to be defined:
â€¢ ğ‘ âˆˆ ğ´âˆ: Then â„(ğ‘) = ğ‘“(ğ‘) is well-defined (since ğ‘“ : ğ´ â†’ ğµ).
â€¢ ğ‘ âˆ‰ ğ´âˆ: Then ğ‘ âˆ‰ ğ´0 (as ğ´0 âŠ† ğ´âˆ), so ğ‘ âˆˆ ğ‘”(ğµ). Thus ğ‘”âˆ’1(ğ‘) exists and is unique.
222 / 246
Proof of SchrÃ¶derâ€“Bernstein Theorem [3]
Step 4: Prove the ranges are disjoint
We show that ğ‘“(ğ´âˆ) and ğ‘”âˆ’1(ğ´ âˆ– ğ´âˆ) are disjoint.
First, observe that:
ğ‘“(ğ´âˆ) = ğ‘“(â‹ƒ
ğ‘›â‰¥0
ğ´ğ‘›) = â‹ƒ
ğ‘›â‰¥0
Now take ğ‘ âˆ‰ ğ´âˆ and let ğ‘ = ğ‘”âˆ’1(ğ‘). We claim ğ‘ âˆ‰ â‹ƒğ‘›â‰¥0 ğµğ‘›:
â€¢ Suppose for contradiction that ğ‘ âˆˆ ğµğ‘› for some ğ‘›
â€¢ Then ğ‘ = ğ‘”(ğ‘) âˆˆ ğ‘”(ğµğ‘›) = ğ´ğ‘›+1 âŠ† ğ´âˆ
â€¢ This contradicts ğ‘ âˆ‰ ğ´âˆ
Hence ğ‘”âˆ’1(ğ´ âˆ– ğ´âˆ) âŠ† ğµ âˆ– â‹ƒğ‘›â‰¥0 ğµğ‘›
= ğµ âˆ– ğ‘“(ğ´âˆ).
Therefore, the ranges ğ‘“(ğ´âˆ) and ğ‘”âˆ’1(ğ´ âˆ– ğ´âˆ) are disjoint.
ğ‘“(ğ´ğ‘›) = â‹ƒ
ğ‘›â‰¥0
ğµğ‘›
223 / 246
Proof of SchrÃ¶derâ€“Bernstein Theorem [4]
Step 5: Prove â„ is injective
Take ğ‘, ğ‘â€² âˆˆ ğ´ with â„(ğ‘) = â„(ğ‘â€²). Consider the cases:
â€¢ Both in ğ´âˆ: Then ğ‘“(ğ‘) = ğ‘“(ğ‘â€²), so ğ‘ = ğ‘â€² (since ğ‘“ is injective).
â€¢ Both outside ğ´âˆ: Then ğ‘”âˆ’1(ğ‘) = ğ‘”âˆ’1(ğ‘â€²), so ğ‘ = ğ‘â€² (since ğ‘” is injective).
â€¢ Mixed case (say ğ‘ âˆˆ ğ´âˆ, ğ‘â€² âˆ‰ ğ´âˆ): Then â„(ğ‘) = ğ‘“(ğ‘) âˆˆ ğ‘“(ğ´âˆ) but â„(ğ‘â€²) = ğ‘”âˆ’1(ğ‘â€²) âˆˆ ğµ âˆ– ğ‘“(ğ´âˆ).
By Step 4, these sets are disjoint, contradicting â„(ğ‘) = â„(ğ‘â€²).
Therefore â„ is injective.
224 / 246
Proof of SchrÃ¶derâ€“Bernstein Theorem [5]
Step 6: Prove â„ is surjective
Let ğ‘ âˆˆ ğµ. Consider the cases:
â€¢ ğ‘ âˆˆ ğ‘“(ğ´âˆ): Then ğ‘ = ğ‘“(ğ‘) for some ğ‘ âˆˆ ğ´âˆ, so â„(ğ‘) = ğ‘“(ğ‘) = ğ‘.
â€¢ ğ‘ âˆ‰ ğ‘“(ğ´âˆ): Let ğ‘ = ğ‘”(ğ‘) âˆˆ ğ´. We claim ğ‘ âˆ‰ ğ´âˆ:
â€£ Suppose for contradiction that ğ‘ âˆˆ ğ´âˆ
â€£ Then ğ‘ âˆˆ ğ´ğ‘› for some ğ‘› â‰¥ 1 (as ğ‘ = ğ‘”(ğ‘) âˆˆ ğ‘”(ğµ), but ğ´0 = ğ´ âˆ– ğ‘”(ğµ))
â€£ So ğ‘ âˆˆ ğ´ğ‘›
= ğ‘”(ğµğ‘›âˆ’1), meaning ğ‘ = ğ‘”(ğ‘â€²) for some ğ‘â€² âˆˆ ğµğ‘›âˆ’1
â€£ Since ğ‘” is injective and ğ‘ = ğ‘”(ğ‘) = ğ‘”(ğ‘â€²), we have ğ‘ = ğ‘â€² âˆˆ ğµğ‘›âˆ’1 âŠ† ğ‘“(ğ´âˆ)
â€£ This contradicts ğ‘ âˆ‰ ğ‘“(ğ´âˆ)
Therefore ğ‘ âˆ‰ ğ´âˆ, and â„(ğ‘) = ğ‘”âˆ’1(ğ‘) = ğ‘”âˆ’1(ğ‘”(ğ‘)) = ğ‘.
Therefore â„ is surjective.
Conclusion: Since â„ is both injective and surjective, â„ is a bijection, so ğ´ â‰ˆ ğµ. â–¡
225 / 246
Large Cardinal Numbers
â€œThe essence of mathematics is its freedom.â€
â€” Georg Cantor
Beyond â„µ0: Hierarchies of Infinity
Weâ€™ve seen that â„µ0 = |â„•| is the smallest infinite cardinality. But are there larger infinities beyond â„µ0?
Cantor showed that there are infinitely many distinct sizes of infinity, forming an endless hierarchy of
ever-growing infinities.
|â„•| < |â„| < |ğ’«ï¸€(â„)| < |ğ’«ï¸€(ğ’«ï¸€(â„))| < â€¦
This discovery fundamentally changed our understanding of the infinite.
Two key hierarchies help us organize these infinities:
â€¢ The â„¶ (beth) numbers â„¶0, â„¶1, â„¶2, â€¦ â€” constructive hierarchy built by repeatedly taking powersets
â€¢ The â„µ (aleph) numbers â„µ0, â„µ1, â„µ2, â€¦ â€” ordinal hierarchy indexing all infinite cardinals by their order
227 / 246
Beth Numbers: The Powerset Hierarchy
Definition 90: The beth numbers (from Hebrew letter ×‘) form a constructive hierarchy defined
recursively using the powerset operation:
â€¢ â„¶0 = â„µ0 = |â„•| (countable infinity â€” the starting point)
â€¢ â„¶ğ‘›+1 = 2â„¶ğ‘› = |ğ’«ï¸€(set of size â„¶ğ‘›)| (apply powerset operation)
â€¢ â„¶ğœ† = sup
â„¶ğ›¼ (for limit ordinal ğœ†)
ğ›¼<ğœ†
Key insight: Each beth number is the cardinality of the powerset of the previous one.
This gives us a concrete, algorithmic hierarchy: we know exactly how to construct each level!
Note: The beth hierarchy is a natural generalization of Cantorâ€™s diagonal argument: each step â„¶ğ‘› â†’ â„¶ğ‘›+1
applies the result that ğ‘† â‰º ğ’«ï¸€(ğ‘†) for any set ğ‘†.
246 / 228
Examples of Beth Numbers
Example: The first few beth numbers:
Beth Value Interpretation
â„¶0 â„µ0 = |â„•| Countable infinity
â„¶1 â„¶2 2â„µ0 = |ğ’«ï¸€(â„•)| = |â„| = ğ”  The continuum (real numbers)
2ğ”  = |ğ’«ï¸€(â„)| All functions â„ â†’ â„, all subsets of â„
â„¶3 2â„¶2 = |ğ’«ï¸€(ğ’«ï¸€(â„))| All relations on â„
By Cantorâ€™s theorem, we know â„¶0 < â„¶1 < â„¶2 < â„¶3 < â€¦ is a strictly increasing sequence.
Each powerset operation produces a provably larger infinity!
229 / 246
Aleph Numbers: Indexing All Infinite Cardinals
Definition 91: The aleph numbers (from Hebrew letter ×) enumerate all infinite cardinal numbers in
their natural order:
â€¢ â„µ0 = |â„•| â€” the smallest infinite cardinal (countable infinity)
â€¢ â„µ1 â€” the next infinite cardinal after â„µ0 (the smallest uncountable cardinal)
â€¢ â„µ2 â€” the next infinite cardinal after â„µ1
â€¢ In general: â„µğ›¼+1 is the smallest cardinal strictly larger than â„µğ›¼
Unlike beth numbers (defined by powerset), aleph numbers are defined abstractly by their order.
We donâ€™t know how to â€œconstructâ€ â„µ1 from â„µ0 â€” we only know it is the â€œnextâ€ cardinal!
246 / 230
Notes on Aleph Hierarchy
Note: Each aleph is actually an initial ordinal: the smallest ordinal of that cardinality.
â€¢ For example, â„µ0 = ğœ”, the first infinite ordinal.
â€¢ â„µ1 = ğœ”1, the first uncountable ordinal.
â€¢ â€œIntermediateâ€ ordinals like ğœ” + 1, ğœ” Ã— 2, ğœ”2
, ğœ”ğœ”
, â€¦ all have cardinality â„µ0.
This connects cardinality to ordinal number theory.
Note: The alephs are â€œordinal-indexedâ€: â„µ0, â„µ1, â€¦, â„µğœ”, â„µğœ”+1, â€¦ It extends through all ordinal numbers!
For a limit ordinal ğœ†:
â„µğœ† = â‹ƒ
ğ›¼<ğœ†
â„µğ›¼
= sup
ğ›¼<ğœ†
â„µğ›¼
231 / 246
Aleph vs Beth: Two Fundamentally Different Hierarchies
Beth hierarchy (constructive):
Aleph hierarchy (ordinal):
â€¢ Start: â„¶0 = â„µ0 = |â„•|
â€¢ Start: â„µ0 = â„¶0 = |â„•|
â€¢ Rule: â„¶ğ‘›+1 = 2â„¶ğ‘› (powerset)
â€¢ Rule: â„µğ‘›+1 = â€œnext cardinalâ€
â€¢ Algorithmic: built by iteration
â€¢ Axiomatic: built by well-ordering
â€¢ We know exactly what each is
â€¢ We know the order, not values
powerset
powerset powerset
â„¶1 = 2â„µ0 â„¶2 = 2â„¶1 â„¶3 = 2â„¶2
â€¦
â„µ0 = â„¶0
?
successor
â„µ1 â„µ2 â„µ3â€¦
successor successor
How these two diverging hierarchies relate is one of deepest â€œunsolvedâ€ questions in mathematics.
Central question: Is â„µ1 = â„¶1 = ğ” ? This is the Continuum Hypothesis.
232 / 246
The Continuum Hypothesis (CH): Cantorâ€™s Great Question
Definition 92: The Continuum Hypothesis (CH) states that there is no infinite cardinal strictly
between â„µ0 and the cardinality of the continuum:
â„µ1 = â„¶1 = 2â„µ0 = |â„| = ğ” 
In other words: every infinite subset of â„ is either countable (â„µ0) or has the same size as â„ (ğ” ).
Georg Cantor formulated CH in 1878 and believed it to be true. He spent decades trying to prove it.
â€œThe question whether there exists a transfinite number between â„µ0 and 2â„µ0 has tormented me.â€ 5
Despite geniously discovering the transfinite numbers, Cantor could neither prove nor disprove CH.
This struggle contributed to his mental health difficulties in later life.
5Not a real quote, but captures his sentiment!
233 / 246
What CH Implies?
Examples (if CH is true):
â€¢ The real numbers â„ have cardinality â„µ1 (first uncountable cardinal)
â€¢ Every uncountable subset of â„ is equinumerous to â„
â€¢ There are â€œno infinities betweenâ€ countable and continuum
â€¢ The hierarchies align at the first step: â„µ1 = â„¶1
â€¢ All â€œnaturally occurringâ€ uncountable sets in analysis have the same size
Examples (if CH is false):
â€¢ The real numbers â„ have cardinality strictly larger than â„µ1 (e.g., ğ”  = â„µ2 or higher)
â€¢ There exist uncountable subsets of â„ with cardinalities between â„µ0 and |â„|
â€¢ The hierarchies diverge: â„µ1 < â„¶1
â€¢ A richer structure of infinite cardinalities exists
â€¢ Some â€œnaturally occurringâ€ sets in analysis may have different sizes
Are there hidden infinities between countable and continuum, or just these two?
234 / 246
The Generalized Continuum Hypothesis (GCH)
Definition 93: The Generalized Continuum Hypothesis (GCH) extends CH to all infinite cardinals:
For every infinite cardinal ğœ…:
2ğœ… = ğœ…+
where ğœ…+ denotes the immediate successor cardinal after ğœ….
This means: â„µğ‘›
= â„¶ğ‘› for all ordinals ğ‘› (finite and transfinite).
What GCH claims: The two hierarchies completely coincide at every level!
There is only one natural hierarchy of infinite cardinals, and the powerset operation always produces
the very next cardinal in the sequence.
235 / 246
What GCH Implies?
Examples (if GCH is true):
â€¢ Every aleph is a beth: â„µğ‘›
= â„¶ğ‘› for all ordinals ğ‘›
â€¢ Powerset always gives the next cardinal: 2â„µğ›¼ = â„µğ›¼+1
â€¢ No â€œgapsâ€ in the cardinal hierarchy â€” maximally simple structure
â€¢ All questions about cardinal arithmetic have definite answers
â€¢ The universe of sets is â€œneatâ€ and predictable
Examples (if GCH is false):
â€¢ The hierarchies diverge at some level: â„µğ›¼ < â„¶ğ›¼ for some ğ›¼
â€¢ Powerset can â€œjumpâ€ multiple levels: 2â„µğ›¼ > â„µğ›¼+1
â€¢ Cardinal arithmetic has complex, unpredictable behavior
â€¢ The universe of sets is â€œwildâ€ with hidden structure
â€¢ Different models can have vastly different cardinal behaviors
Is the cardinal hierarchy maximally simple or is reality more complex?..
236 / 246
Hilbertâ€™s First Problem
In 1900, David Hilbert presented 23 problems that shaped 20th-century mathematics.
Problem 1 was to resolve the Continuum Hypothesis â€” showing its fundamental importance.
Early attempts to settle CH:
â€¢ Cantor (1878â€“1918): Believed CH was true, could not prove it
â€¢ Hilbert (1900): Made it the first of his famous problems
â€¢ Zermelo (1908): Developed axiomatic set theory (ZF), but CH remained open
â€¢ Fraenkel (1922): Extended to ZFC (with Axiom of Choice), CH still unresolved
â€¢ GÃ¶del (1940): Proved CH is consistent with ZFC (cannot be disproved)
â€¢ Cohen (1963): Proved Â¬CH is also consistent â€” breakthrough!
237 / 246
Cohenâ€™s Independence Result (1963)
Theorem 26 (Cohen, 1963): The Continuum Hypothesis is independent of ZFC (Zermeloâ€“Fraenkel set
theory with the Axiom of Choice):
â€¢ ZFC cannot prove CH
â€¢ ZFC cannot disprove CH
â€¢ Both â€œZFC + CHâ€ and â€œZFC + Â¬CHâ€ are consistent (assuming ZFC is consistent)
What Cohen proved using forcing: The value of 2â„µ0 is not determined by the axioms of ZFC!
We can construct models where:
â€¢ â„µ1 = â„¶1 = 2â„µ0 (CH holds)
â€¢ â„µ2 = â„¶1 = 2â„µ0 (one intermediate cardinal)
â€¢ â„µğœ”
= â„¶1 = 2â„µ0 (countably many intermediate cardinals)
â€¢ â„µğœ”1
= â„¶1 = 2â„µ0 (uncountably many intermediate cardinals)
â€¢ Even: â„µğ›¼
= â„¶1 = 2â„µ0 for arbitrarily large ğ›¼!
238 / 246
The Freedom of Infinity
Different models of ZFC can have wildly different cardinal structures!
Universe where CH holds:
â€¢ â„µ1 = â„¶1 = 2â„µ0 = |â„| â€” hierarchies align
â€¢ Every subset of â„ is either countable (â„µ0) or has
the same cardinality ğ” 
â€¢ No â€œintermediateâ€ infinities
Universe where CH fails:
â€¢ â„µ1 < 2â„µ0 = |â„| â€” hierarchies diverge
â€¢ â€œIntermediateâ€ infinities exist (between â„• and â„)
â€¢ â„ can be arbitrarily large
â€¢ Much richer structure
Before 1963: We thought CH must be either true or false.
After Cohen: CH is independent â€” both answers are mathematically valid!
Key insight: There is no single fixed mathematical reality.
Different axiom systems can give different but equally consistent answers.
239 / 246
What Is Mathematical Truth?
If CH can be neither proved nor disproved, what does it even mean to ask â€œIs CH true?â€
Two philosophical perspectives:
Platonist view:
â€¢ Mathematical objects exist independently
â€¢ CH is either true or false in reality
â€¢ We just havenâ€™t found the â€œrightâ€ axioms yet
â€¢ Approach: Search for natural axioms beyond ZFC
(like large cardinal axioms)
Formalist view:
â€¢ Mathematics is just symbol manipulation
â€¢ â€œTruthâ€ depends on which axioms you choose
â€¢ CH is true in some models, false in others
â€¢ Approach: Study all possible models
(â€œmultiverseâ€) and their properties
240 / 246
Modern Perspectives on CH
Most mathematicians today take a pragmatic approach:
Instead of asking â€œIs CH absolutely true?â€, modern set theory asks more productive questions:
â€¢ In which models of ZFC does CH hold?
â€¢ What interesting mathematics follows from CH? From Â¬CH?
â€¢ Do certain â€œnaturalâ€ axioms beyond ZFC settle CH?
â€¢ Which axiom systems are most useful for specific areas of mathematics?
Note: This shift mirrors similar debates in physics: rather than asking if string theory is â€œThe True Theory,â€
physicists ask what predictions it makes and whether itâ€™s useful for understanding nature.
241 / 246
Summary: Large Cardinal Numbers
Two infinite hierarchies with different constructions:
â€¢ Beth numbers: â„¶0 = â„µ0, â„¶ğ‘›+1 = 2â„¶ğ‘› â€” built step-by-step using powersets
â€¢ Aleph numbers: â„µ0, â„µ1, â„µ2, â€¦ â€” enumerate all infinite cardinals in order
Both start at â„µ0 = â„¶0, but their relationship afterward is not fixed by ZFC axioms.
The Continuum Hypothesis: Does â„µ1 = 2â„µ0 ?
â€¢ GÃ¶del (1940): Showed ZFC + CH is consistent
â€¢ Cohen (1963): Showed ZFC + Â¬CH is also consistent
Conclusion: CH is independent of ZFC. The â€œsizeâ€ of â„ depends on which axioms you choose.
What we learned: Mathematics does not have a unique â€œrealityâ€ â€” different axiom systems can give
different answers to the same question, yet remain equally consistent.
242 / 246
Outline
Â§1 Â§2 Â§3 Â§4 Â§5 Â§6 Â§7 Â§8 Â§9 Â§10 Â§11 Â§12 Â§13 Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
Properties of Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
Equivalence Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Composition of Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Closures of Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
Order Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
Lattices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
Well Orders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
Cardinality & Infinity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
Enumerations and Countability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
SchrÃ¶derâ€“Bernstein . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
Large Cardinal Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
243 / 246
TODO
â€¢ Applications of lattices in:
â€£ Formal concept analysis
â€£ Domain theory in computer science
â€£ Algebraic topology
â€£ Cryptography (lattice-based cryptography)
â€¢ Advanced topics in set theory:
â€£ Cardinal arithmetic
â€£ Ordinal numbers
â€£ Forcing and independence results
â€£ Large cardinals
â€¢ Connections to Boolean algebra (next lecture)
â€¢ Applications in formal logic and proof theory
244 / 246
Looking Ahead: Boolean Algebra
The next lecture will explore Boolean algebra, which provides the mathematical foundation for:
â€¢ Digital circuit design and computer hardware
â€¢ Propositional logic and automated reasoning
â€¢ Database query optimization
â€¢ Formal verification of software and hardware systems
Key topics will include:
â€¢ Boolean functions and their representations
â€¢ Normal forms (CNF, DNF)
â€¢ Minimization techniques (Karnaugh maps, Quine-McCluskey)
â€¢ Functional completeness and Postâ€™s theorem
â€¢ The satisfiability problem (SAT) and its computational complexity
245 / 246
Preview: Formal Logic
Following Boolean algebra, we will study formal logic, covering:
â€¢ Propositional and predicate logic
â€¢ Natural deduction and proof systems
â€¢ Completeness and soundness theorems
â€¢ Applications to program verification and AI reasoning
This progression from sets â†’ relations â†’ functions â†’ Boolean algebra â†’ logic provides a solid
foundation for advanced topics in discrete mathematics and computer science.
Binary relations are the bridge between sets and functions â€” they model how objects connect,
organize, and interact in mathematical structures and real-world systems.
246 / 246
```

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ ĞºĞ¾Ğ½ÑĞ¿ĞµĞºÑ‚Ğ°:

```
## ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ
ĞÑ€Ğ´Ğ¸Ğ½Ğ°Ğ»Ñ‹ ([Ğ»Ğ°Ñ‚.](https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D1%82%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Ğ›Ğ°Ñ‚Ğ¸Ğ½ÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº")Â ordinalisÂ - Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞ¾Ğ²Ñ‹Ğ¹) - ÑÑ‚Ğ¾ Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ‡Ğ¸ÑĞµĞ» Ğ² Ğ²Ğ¸Ğ´Ğµ [Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²](ĞœĞ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾.md).

---
## ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ñ‡Ğ¸ÑĞµĞ» Ñ‡ĞµÑ€ĞµĞ· Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ°
- $0 = \emptyset$
- $1 = \{0\} = \{\emptyset\}$
- $2 = \{0, 1\} = \{\emptyset, \{\emptyset\}\}$
  $...$
- $\omega = \{0, 1, 2, ...\} = \mathbb{N}$
- $\omega + 1 = \{0, 1, 2, ...\, \omega\} = \mathbb{N} + 1$
- $\alpha = \omega^\alpha$
- $\omega_0, ..., \omega^{\omega^{\omega^{...}}}, ..., \varepsilon_0, ..., \Gamma_0, ..., \omega_1$

$\omega$ ĞºĞ°Ğº Ñ€Ğ°Ğ· Ğ¸ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¼ Ğ±ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ñ‹Ğ¼ Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ğ»Ğ¾Ğ¼

---
## ĞšĞ°Ñ€Ğ´Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ Ğ±ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ñ‹Ñ… Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²
Ğ•ÑÑ‚ÑŒ 2 ĞºĞ°Ñ€Ğ´Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ $\beth$ Ğ¸ $\aleph$. ĞĞ½Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ·ÑƒÑÑ‚ 2 ÑĞµÑ€Ğ¸Ğ¸ ĞºĞ°Ñ€Ğ´Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ĞµĞ¹ $\beth_n$ Ğ¸ $\aleph_n$.
--- start-multi-column: ExampleRegion1  
```column-settings  
number of columns: 2
Border: false
Shadow: false
```

- $\aleph_0 = |\mathbb{N}|$
- $\aleph_1 = the\; next\; smallest\; infinite\; cardinal\; after\; \aleph_0$
- $\aleph_2 = the\; next\; smallest\; infinite\; cardinal\; after\; \aleph_1$
- $...$
- $\aleph_{n + 1} = the\; next\; smallest\; infinite\; cardinal\; after\; \aleph_n$

--- end-column ---

- $\beth_0 = |\mathbb{N}|$
- $\beth_1 = |\cal{P}(\mathbb{N})|$
- $\beth_2 = |\cal{P}(\cal{P}(\mathbb{N}))|$
- $...$
- $\beth_{n + 1} = |\cal{P}(set\; size\; of\; \beth_n)|$

--- end-multi-column

---
## [Wiki](https://ru.wikipedia.org/wiki/ĞŸĞ¾Ñ€ÑĞ´ĞºĞ¾Ğ²Ğ¾Ğµ_Ñ‡Ğ¸ÑĞ»Ğ¾)
```

ĞĞ°Ğ¿Ğ¸ÑˆĞ¸ ĞºĞ¾Ğ½ÑĞ¿ĞµĞºÑ‚ Ğ¿Ğ¾ Ñ‚ĞµĞ¼Ğµ Ñ€ĞµÑˆĞµÑ‚ĞºĞ° Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼